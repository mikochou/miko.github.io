<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十六）]]></title>
    <url>%2F2019%2F03%2F31%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[认真学习啦leetcode刷题记录(十六)646.Maximum Length of Pair Chain12345cur, res = float(&apos;-inf&apos;), 0 for p in sorted(pairs, key = lambda x:x[1]) : if cur &lt; p[0] : cur, res = p[1], res+1 return res 406.Queue Reconstruction by Heightinput: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]subarray after step 1: [[7,0], [7,1]]subarray after step 2: [[7,0],[6,1], [7,1]]12345678910111213141516d = &#123;&#125; for h,k in people: if h not in d: d[h] = [[h,k]] else: d[h].append([h,k]) res =[] for h in sorted(d.keys(), reverse = True): group = sorted(d[h]) if not res: res += group else: for h,k in group: res.insert(k,[h,k]) return res 101.Symmetric Tree123456789101112if not root: return True stack = [(root.left,root.right)] while stack: cur = stack.pop() l,r = cur[0],cur[1] if not l and not r: continue if not l and r or not r and l or l.val != r.val: return False stack.append((l.left,r.right)) stack.append((l.right,r.left)) return True 213.House Robber II1234567def robs(nums): a,b = 0,0 for i in nums: a,b = b, max(a+i,b) return b return max(robs(nums[len(nums)!=1:]),robs(nums[:-1])) 337.House Robber IIIf2(node) = f1(node.left) + f1(node.right)andf1(node) = max( f2(node.left)+f2(node.right)+node.value, f2(node) )123456789def rob(self, root): return self.robs(root)[1] def robs(self, node): if node is None: return (0,0) l = self.robs(node.left) r = self.robs(node.right) return (l[1]+r[1], max(l[1]+r[1],l[0]+r[0]+node.val)) 102.Binary Tree Level Order Traversal12345ans,level = [],[root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 653.Two Sum IV - Input is a BST123456789if not root: return False bfs,s=[root],set() for i in bfs: if k-i.val in s: return True s.add(i.val) if i.left: bfs.append(i.left) if i.right: bfs.append(i.right) return False 494.Target Sum123456789if not nums: return 0 dic = &#123;nums[0]:1,-nums[0]:1&#125; if nums[0] != 0 else &#123;0:2&#125; for i in range(1,len(nums)): tdic = &#123;&#125; for d in dic: tdic[d+nums[i]] = tdic.get(d+nums[i],0) + dic.get(d,0) tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0) dic = tdic return dic.get(S,0) 309.Best Time to Buy and Sell Stock with Cooldown123456789if len(prices)&lt;2: return 0 sell,buy,prev_sell,prev_buy=0,-prices[0],0,0 for price in prices: prev_buy=buy buy=max(prev_sell-price,prev_buy) prev_sell=sell sell=max(prev_buy+price,prev_sell) return sell 11.Container With Most Water123456789i,j = 0, len(height)-1 water = 0 while i&lt;j: water = max(water,(j-i)*min(height[i],height[j])) if height[i] &lt; height[j]: i+=1 else: j-=1 return water 75.Sort Colors123456789101112p1,p2=0,len(nums)-1 p=0 while p&lt;=p2: if nums[p]&lt;1: nums[p],nums[p1]=nums[p1],nums[p] p1+=1 p+=1 elif nums[p]&gt;1: nums[p],nums[p2]=nums[p2],nums[p] p2-=1 else: p+=1 221.Maximal Square1234567891011if not matrix: return 0 m,n = len(matrix), len(matrix[0]) dp = [[0 if matrix[i][j] == &apos;0&apos; else 1 for j in range(0,n)] for i in range(0,m)] for i in range(1,m): for j in range(1,n): if matrix[i][j]==&apos;1&apos;: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else: dp[i][j] = 0 res = max(max(row) for row in dp) return res**2 560.Subarray Sum Equals K1234567dic = &#123;0:1&#125; res = presum = 0 for num in nums: presum += num res += dic.get(presum - k,0) dic[presum] = dic.get(presum,0) + 1 return res 78.Subsets1234res = [[]]for num in sorted(nums): res+=[item+[num] for item in res]return res 98.Validate Binary Search Tree123456def isValidBST(self, root,floor=float(&apos;-inf&apos;), ceiling=float(&apos;inf&apos;)): if not root: return True if root.val &lt;= floor or root.val &gt;= ceiling: return False return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十五）]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[沉迷动态规划leetcode刷题记录(十五)24.Swap Nodes in Pairspre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next12345678dummy = pre = ListNode(0) pre.next = head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, a.next, b.next = b, b.next,a pre = a return dummy.next 414.Third Maximum Number123456789m1 = m2 = m3 = -float(&quot;inf&quot;) for num in nums: if num &gt; m1: m1,m2,m3 = num, m1,m2 elif m2&lt;num&lt;m1: m2,m3 = num,m2 elif m3&lt;num&lt;m2: m3 = num return m3 if m3&gt; -float(&quot;inf&quot;) else m1 另一个方法：1return sorted(set(nums))[-3] if len(set(nums))&gt;2 else max(nums) 515.Find Largest Value in Each Tree Row1234567891011121314ans = [] if not root: return ans queue = [root] while queue: ans.append(max(x.val for x in queue)) new = [] for node in queue: if node.left: new.append(node.left) if node.right: new.append(node.right) queue = new return ans 167.Two Sum II - Input array is sorted123456789l,r = 0, len(numbers) - 1 while l&lt;r: s = numbers[l] + numbers[r] if s == target: return [l+1,r+1] elif s &lt; target: l += 1 else: r -= 1 41.First Missing Positivehashtable12345678910for i in xrange(len(nums)): if nums[i] &gt; len(nums) or nums[i] &lt;= 0: nums[i] = len(nums) + 1 for i in xrange(len(nums)): if abs(nums[i])-1 &lt; len(nums): nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]) for i in xrange(len(nums)): if nums[i] &gt; 0: return i+1 return len(nums) + 1 129.Sum Root to Leaf Numbers123456789101112if not root: return 0 stack = [(root, str(root.val))] res = 0 while stack: root,s = stack.pop() if not root.left and root.right: res += int(s) if root.left: stack.append((root.left,s+str(root.left.val))) if root.right: stack.append((root.right,s+str(root.right.val))) return res 139.Word Break12345678dp = [False]*(len(s)+1) dp[0] = True for i in range(len(s)): if dp[i]: for j in range(i,len(s)): if s[i:j+1] in wordDict: dp[j+1] = True return dp[-1] 993.Cousins in Binary Tree123456789def dfs(node,parent,dp,mod): if node: if node.val == mod: return dp,parent return dfs(node.left,node,dp+1,mod) or dfs(node.right,node,dp+1,mod) dx,px = dfs(root,None,0,x) dy,py = dfs(root,None,0,y) return dx==dy and px!=py 91.Decode Ways对每个数组首先判断其是否为0，若是将改为dp赋0，若不是，赋上一个dp值，此时相当如加上了dp[i - 1], 然后看数组前一位是否存在，如果存在且满足前一位不是0，且和当前为一起组成的两位数不大于26，则当前dp值加上dp[i - 2]123456789dp = [0 for i in range(3)] dp[0] = 1 for i,n in enumerate(s,1): dp[i%3] = 0 if s[i-1] != &quot;0&quot;: dp[i%3] += dp[(i-1)%3] if i&gt;1 and int(s[i-2:i]) &lt;=26 and int(s[i-2:i])&gt;=10: dp[i%3] += dp[(i-2)%3] return dp[len(s)%3] 413.Arithmetic Slicesdp again12345678cur,s = 0,0 for i in range(2,len(A)): if A[i] - A[i-1] == A[i-1] -A[i-2]: cur+=1 s += cur else: cur = 0 return s 714.Best Time to Buy and Sell Stock with Transaction Fee1234567891011buy = prices[0] res = 0 for p in prices: if buy &gt; p: buy = p else: tmp = p-buy-fee if tmp &gt; 0: res+=tmp buy = p - fee return res 338.Counting Bitsdp again，可以找到规律 1 [1], 2[10] 3[11], 4[100] 5[101] 6[110] 7[111]，所以在现有的res上+1，最后取0～num的res就可以了。1234res = [0,1] while len(res) &lt; num+1: res += [x+1 for x in res] return res[:num+1]]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十四）]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[希望拿到offer！leetcode刷题记录(十四)435.Non-overlapping Intervals1234567891011if not intervals: return 0 intervals.sort(key = lambda x: x.start) intervals = iter(intervals) curEnd,cnt = next(intervals).end,0 for x in intervals: if x.start &lt; curEnd: cnt+=1 curEnd = min(curEnd,x.end) else: curEnd = x.end return cnt 443.String Compression两个指针1234567891011left = i = 0 while i&lt;len(chars): char,length = chars[i],1 while (i+1) &lt; len(chars) and char == chars[i+1]: length, i = length+1, i+1 chars[left] = char if length &gt; 1: len_str = str(length) chars[left+1:left+1+len(len_str)] = len_str left += len(len_str) left,i = left+1,i+1 662.Maximum Width of Binary Tree123456789101112res = 0 level = [(root,0)] while level: new_level = [] res = max(res,level[-1][1]-level[0][1]+1) for node,pos in level: if node.left: new_level.append((node.left,pos*2)) if node.right: new_level.append((node.right,pos*2+1)) level = new_level return res 455.Assign Cookies12345i,j,g,s = 0,0,sorted(g),sorted(s) while i &lt; len(g) and j &lt; len(s): i+=g[i] &lt;= s[j] j+=1 return i 228.Summary Ranges12345678910111213141516def printR(self,l,r): if l == r: return str(l) else: return str(l) +&quot;-&gt;&quot;+str(r) if not nums: return [] res,i,start = [],0,0 while i&lt;len(nums)-1: if nums[i] + 1 != nums[i+1]: res.append(self.printR([start],nums[i])) start = i+1 i += 1 res.append(self.printR(nums[start],nums[i])) return res 153.Find Minimum in Rotated Sorted Array123456789i=0 j=len(nums)-1 while i&lt;j: m=i+(j-i)/2 if nums[m]&gt;nums[j]: i=m+1 else: j=m return nums[i] 606.Construct String from Binary Tree12345678910if not t: return &apos;&apos; result = str(t.val) if t.left: result += &apos;(&apos;+self.tree2str(t.left) + &apos;)&apos; if t.right: result += &apos;(&apos;+self.tree2str(t.right) + &apos;)&apos; elif t.right: result += &apos;()&apos;+ &apos;(&apos;+self.tree2str(t.right) + &apos;)&apos; return result 611.Valid Triangle Number123456789101112ans = 0 nums.sort() for i in range(2,len(nums)): s =0 e = i - 1 while s &lt; e: if nums[s] + nums[e] &gt; nums[i]: ans+= e-s e -= 1 else: s += 1 return ans 74.Search a 2D Matrix123456789101112131415if not matrix or target is None: return False row,cols = len(matrix),len(matrix[0]) low,high = 0,row*cols - 1 while low&lt;=high: mid = (low+high)/2 num = matrix[mid/cols][mid%cols] if num == target: return True elif num&lt;target: low = mid+1 else: high = mid-1 return False 49.Group Anagrams12345678hashmap = &#123;&#125; for st in strs: key = &apos;&apos;.join(sorted(st)) if key not in hashmap: hashmap[key] = [st] else: hashmap[key] += [st] return hashmap.values() 219.Contains Duplicate II之前写过1，还是比较简单的123456dic = &#123;&#125;for i,v in enumerate(nums): if v in dic and i - dic[v] &lt;= k: return True dic[v] = ireturn False 227.Basic Calculator II12345678910111213141516171819202122if not s: return &quot;0&quot; stack,num,sign = [],0,&quot;+&quot; for i in xrange(len(s)): if s[i].isdigit(): num = num*10 + ord(s[i]) - ord(&quot;0&quot;) if(not s[i].isdigit() and not s[i].isspace()) or i == len(s) - 1: if sign == &quot;-&quot;: stack.append(-num) elif sign == &quot;+&quot;: stack.append(num) elif sign == &quot;*&quot;: stack.append(stack.pop()*num) else: tmp = stack.pop() if tmp//num &lt; 0 and tmp%num != 0: stack.append(tmp//num+1) else: stack.append(tmp//num) sign = s[i] num = 0 return sum(stack) 921.Minimum Add to Make Parentheses Valid12345678910i,j = 0,0 for s in S: if s == &quot;(&quot;: j += 1 else: j -= 1 if j&lt;0: i += 1 j += 1 return i + j 229.Majority Element II摩尔投票法：该算法在其局部变量中维护一个序列元素和一个 计数器 ，计数器最初为零。然后，它一次一个地处理序列的元素。处理元素x时，如果计数器为零，则算法将x存储为其维护的序列元素，并将计数器设置为1。否则，它将x与存储的元素进行比较，并使计数器递增（如果相等）或递减计数器。这道题选出两个候选人就行了。1234567891011121314151617181920212223242526if not nums: return [] can1 = 0 can2 = 1 c1 = c2 = 0 for num in nums: if num == can1: c1+=1 elif num == can2: c2+=1 elif c1 == 0: can1, c1 = num,1 elif c2 == 0: can2, c2 = num, 1 else: c1,c2 = c1-1,c2-1 c1,c2 = 0,0 for num in nums: if num == can1: c1+=1 elif num==can2: c2+=1 res, l = [], len(nums) if (c1 &gt; l/3): res.append(can1) if (c2 &gt; l/3): res.append(can2) return res 145.Binary Tree Postorder Traversal12345678res, stack = [],[root] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1]]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十三）]]></title>
    <url>%2F2019%2F03%2F06%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[leetcode刷题记录(十三)毕设咋办啊 141.Linked List Cycle123456789101112131415def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head == None: return False m1 = head m2 = head.next while m2 != None and m2.next != None: m1 = m1.next m2 = m2.next.next if m2 is m1: return True return False 137.Single Number II12345one, two = 0, 0 for x in nums: one, two, three = one ^ x, two | (one &amp; x), two &amp; x one, two = one &amp; ~three, two &amp; ~three return one 674.Longest Continuous Increasing Subsequence12345678910111213if not nums: return 0 l = len(nums) if l &lt;=1 : return 1 res = 1 max1 = 1 for i in range(1,l): if i and nums[i-1] &lt; nums[i]: res +=1 if res &gt; max1: max1 = res else: res = 1 return max1 961.N-Repeated Element in Size 2N Array123456a = [] for i in A: if i not in a: a += [i] else: return i 448.Find All Numbers Disappeared in an Array标记出现了的数字为负数1234for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = -abs(nums[index]) return [index for index,n in enumerate(nums,start=1) if n &gt; 0] 257.Binary Tree Paths123456789def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] if not root.left and not root.right: return [str(root.val)] return [str(root.val)+&apos;-&gt;&apos;+i for i in self.binaryTreePaths(root.left)] + [str(root.val) + &apos;-&gt;&apos; + i for i in self.binaryTreePaths(root.right)] 160.Intersection of Two Linked Lists123456789101112131415161718curA, curB = headA, headB lenA,lenB = 0,0 while curA: lenA += 1 curA = curA.next while curB: lenB += 1 curB = curB.next curA, curB = headA, headB if lenA &gt;= lenB: for i in range(abs(lenA-lenB)): curA = curA.next else: for i in range(abs(lenA-lenB)): curB = curB.next while curB != curA: curA,curB = curA.next,curB.next return curA 162.Find Peak Element123456789101112l = 0 r = len(nums) - 1 while l &lt; r: mid = (r+l)/2 if nums[mid]&gt;nums[mid+1] and nums[mid] &gt; nums[mid-1]: return mid if nums[mid] &lt; nums[mid + 1]: l = mid + 1 else: r = mid - 1 return l 83.Remove Duplicates from Sorted List12345678910111213if head == None: return head cur = head.next pre = head while cur != None: if cur.val == pre.val: pre.next = cur.next cur = cur.next else: cur = cur.next pre = pre.next return head 539.Minimum Time Difference1234567def minutes(p): h,m = map(int,p.split(&apos;:&apos;)) return 60*h+m mins = sorted(map(minutes,timePoints)) mins.append(60*24 + mins[0]) return min(b-a for a,b in zip(mins,mins[1:])) 506.Relative Ranks123sort = sorted(nums)[::-1] rank = [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;]+map(str,range(4,len(nums)+1)) return map(dict(zip(sort,rank)).get,nums) 402.Remove K Digits12345678def shrink(num): a = len(num) for i in range(a - 1): if num[i] &gt; num[i+1]: return num[:i]+num[i+1:]for i in range(k): num = shrink(num)return str(int(num)) if num else &quot;0&quot; 404.Sum of Left Leaves123456789self.sum = 0 def dfs(root): if root: if root.left and not root.left.left and not root.left.right: self.sum += root.left.val dfs(root.left) dfs(root.right) dfs(root) return self.sum]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十二）]]></title>
    <url>%2F2019%2F03%2F03%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[leetcode刷题记录(十二)菜 33.Search in Rotated Sorted Array用二分查找1234567891011121314151617181920212223242526def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return -1 low, high = 0, len(nums)-1 while low &lt;= high: mid = (low+high)&gt;&gt;1 if target== nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 35.Search Insert Position因为是sorted所以用二分查找123456789101112131415161718class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; low = 0 high = len(nums) - 1 while low&lt;=high: mid = (low+high)//2 if nums[mid] == target: return mid if nums[mid] &gt; target: high = mid - 1 if nums[mid] &lt; target: low = mid + 1 return ((high+low)//2 + 1) 其实刚开始想到的是一个很慢的方法-&gt;123nums.append(target)nums.sort()return nums.index(target) 39.Combination Sumdfs123456789101112res = [] def dfs(target, index, path): if target &lt; 0: return if target == 0: res.append(path) return for i in range(index,len(candidates)): dfs(target-candidates[i],i,path+[candidates[i]]) dfs(target,0,[]) return res 53.Maximum Subarray123456cur = maxs = -float(&apos;inf&apos;) for i in xrange(len(nums)): cur +=nums[i] cur = max(cur,nums[i]) maxs = max(maxs,cur) return maxs 538.Convert BST to Greater Tree12345678910111213a = 0 def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return None self.convertBST(root.right) self.a += root.val root.val = self.a self.convertBST(root.left) return root 860.Lemonade Change12345678910111213141516five, ten = 0, 0 for i in bills: if i == 5: five+=1 elif i == 10: five -=1 ten +=1 else: if ten &gt; 0: five -=1 ten -=1 else: five -=3 if five &lt; 0: return False return True 100.Same Tree123456if p == None and q == None: return True if p and q: return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) else: return False 594.Longest Harmonious Subsequence12345678910111213141516def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in nums: if i not in m: m[i] = 1 else: m[i] += 1 l = 0 for i in m: if m.get(i+1): l = max(l,m[i]+m[i+1]) return l 671.Second Minimum Node In a Binary Tree1234567891011121314151617def findSecondMinimumValue(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = float(&apos;inf&apos;) minx = root.val def dfs(node): if node: if minx&lt;node.val&lt;self.ans: self.ans = node.val elif node.val == minx: dfs(node.left) dfs(node.right) dfs(root) return self.ans if self.ans &lt; float(&apos;inf&apos;) else -1 152.Maximum Product Subarray普通方法1234567max1 = big = small = nums[0] for i in nums[1:]: temp = big big = max(i,i*big,i*small) small = min(i,i*temp,i*small) max1 = max(max1,big) return max1 在讨论里看到的奇妙方法123456def maxProduct(self, A): B = A[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B) 942.DI String Match123456789101112131415161718def diStringMatch(self, S): &quot;&quot;&quot; :type S: str :rtype: List[int] &quot;&quot;&quot; i = 0 j = len(S) res = [] for x in S: if x==&apos;I&apos;: res.append(i) i+=1 else: res.append(j) j-=1 res.append(j if S[-1]==&apos;D&apos; else i) return res]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（十）]]></title>
    <url>%2F2018%2F08%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录(十)开始按顺序刷了（hard还是随缘吧）～语言班也开课了，事情多了起来了，希望有一个永无止境的八月 1. Two Sum在python中，寻找元素在dictionary中的时间复杂度为O(1),在list中为O(n)123456789n = len(nums) if n&lt;=1: return False dic = &#123;&#125; for i in range(n): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 2. Add Two Numbers12345678910ret = cur = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val/10 cur.next = ListNode(val%10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next 3. Longest Substring Without Repeating Characters找最长不重复子串，觉得这个思想以后还会用到123456789start = maxL = 0 usedCh = &#123;&#125; for i in range(len(s)): if s[i] in usedCh and start &lt;= usedCh[s[i]]: start = usedCh[s[i]] + 1 else: maxL = max(maxL,i-start+1) usedCh[s[i]] = i return maxL 5. Longest Palindromic Substring找最长回文子串，似乎做过第一种办法直接解，暴力🐸123456789101112131415161718192021class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = &quot;&quot; for i in xrange(len(s)): tmp = self.helper(s,i,i) if len(tmp) &gt;len(res): res = tmp tmp = self.helper(s,i,i+1) if len(tmp) &gt;len(res): res = tmp return res def helper(self,s,l,r): while l&gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1 r+=1 return s[l+1:r] 第二种学习一下Manacher算法：在字符串首尾以及各个字符间插入一个字符，定义辅助数组p[]表示以i为中心的最长回文的半径，则p[i]-1就是原字符串中最长回文的长度。p[]的求解：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。则p[i] = min(p[2 * id - i], mx - i)12345678910111213141516def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; T = &apos;#&apos;.join(&apos;^&#123;&#125;$&apos;.format(s)) n = len(T) p = [0]*n c = r= 0 for i in range(1,n-1): while T[i+1+p[i]] == T[i-1-p[i]]: p[i]+=1 if i + p[i] &gt;r: c,r=i,i+p[i] maxLen, centerIndex = max((n, i) for i, n in enumerate(p)) return s[(centerIndex - maxLen)//2: (centerIndex + maxLen)//2] 6. ZigZag Conversion12345678910111213if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index,step = 0,1 for x in s: L[index] += x if index == 0: step =1 elif index == numRows - 1: step = -1 index +=step return &apos;&apos;.join(L) 7. Reverse Integer要考虑到边界情况123s = (x&gt;0) - (x&lt;0) r = int(str(x*s)[::-1]) return s*r*(r&lt;2**31) 不用str的方法1234567891011i,res,sign = 0,0,1 if x&lt;0: sign = -1 x = abs(x) while x!=0: res=res*10+(x%10) x/=10 if res&lt;-2147483648 or res&gt;2147483648: return 0 else: return res*sign 9.Palindrome Number判断数字是否是回文1234567if x&lt;0: return False p,res = x,0 while p: res = res*10 +p%10 p /= 10 return res == x 14. Longest Common Prefix1234567891011121314s = len(strs) if s == 0: return &apos;&apos; lens = [len(str) for str in strs] min_len = min(lens) result = &apos;&apos; for i in range(1,min_len+1): pre = strs[0][:i] for s in strs: if s[:i] != pre: return result result = pre return result 真的好忙啊……]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（九）]]></title>
    <url>%2F2018%2F07%2F18%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录(九)在天国的动态规划 Fizz Buzz1return [str(i)*(i%5!=0 and i%3!=0) + &apos;Fizz&apos;*(i%3 == 0) + &apos;Buzz&apos;*(i%5 ==0) for i in range(1,n+1)] Single Number123456dic =&#123;&#125;for num in nums: dic[num] = dic.get(num,0) +1for key, value in dic.items(): if value == 1: return key 另外还有一种时间复杂度为o(n)的方法：1return reduce(lambda x,y:x^y, nums) reduce()函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果 Product of Array Except Self1234567891011output=[] p = 1 n = len(nums) for i in range(0,n): output.append(p) p = p*nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i]*p p = p*nums[i] return output Sum of Two Integers123456MAX = 0x7FFFFFFF MIN = 0x80000000 mask = 0xFFFFFFFF while b!=0: a,b = (a^b)&amp;mask,((a&amp;b)&lt;&lt;1)&amp;mask return a if a&lt;=MAX else ~(a^mask) Top K Frequent Elements顺便学习heapq模块的使用。 item = heapreplace(heap,item) 弹出并返回最小值 nlargest(n , iterbale, key=None) 从堆中找出做大的N个数，key的作用和sorted( )方法里面的key类似，用列表元素的某个属性和函数作为关键字。 nsmallest(n, iterable, key=None) 找到堆中最小的N个数。 heappushpop() 将值插入到堆中同时弹出堆中的最小值。 merge(*iterables) 合并多个堆然后输出12345from collections import Counter import heapq - [ ] c = Counter(nums) return heapq.nlargest(k,c,c.get) Excel Sheet Column Number12345n=len(s) num=0 for i,x in enumerate(s): num+=(ord(x)-64)*26**(n-i-1) return num 还可以用reduce做=。= Majority Element12345678910 return sorted(nums)[len(nums)//2]//另一种办法pool = [] n = len(nums) for i in range(n): if nums[i] not in pool: if nums.count(nums[i]) &gt; n/2: return nums[i] pool.append(nums[i]) Binary Tree Inorder Traversal递归挺简单的，所以只做了迭代1234567891011stack=[] output=[] while True: while root: stack.append(root) root = root.left if not stack: return output node = stack.pop() output.append(node.val) root = node.right Best Time to Buy and Sell Stock1234567if not prices: return 0 max_profit = sell_price = 0 for price in prices[::-1]: sell_price = max(sell_price, price) max_profit = max(max_profit,sell_price - price) return max_profit Best Time to Buy and Sell Stock II惊了这道题我还想了好久，原来这么简单orz1return sum(max(prices[i+1]-prices[i],0) for i in range(len(prices)-1)) Permutations1234567891011121314if not nums: return None stack = [[[nums[0]],0]] i,res = 0, [] while(stack): arr, index = stack.pop() if index == len(nums)-1: res.append(arr) else: for i in range(len(arr)+1): newPermutation = arr[:i]+[nums[index+1]]+arr[i:] stack.append([newPermutation,index+1]) return res First Unique Character in a String123letters=&apos;abcdefghijklmnopqrstuvwxyz&apos; index = [s.index(l) for l in letters if s.count(l) == 1] return min(index) if len(index) &gt; 0 else -1 Generate Parentheses也是全排列问题1234567891011res = [] def dfs(l,r,path,res): if r &lt; l or l == -1 or r == -1: return if l == 0 and r == 0: res.append(path[:]) else: dfs(l-1, r, path + &quot;(&quot;, res) dfs(l, r-1, path + &quot;)&quot;, res) dfs(n,n,&quot;&quot;,res) return(res) Missing Number12n = len(nums) return n*(n+1)/2 - sum(nums)]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（八）]]></title>
    <url>%2F2018%2F05%2F30%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（八）349. Intersection of Two Arrays123456789 def intersection(self, nums1, nums2): “”” :type nums1: List[int] :type nums2: List[int] :rtype: List[int] “”” n1 = set(nums1) n2 = set(nums2) return list(n1&amp;n2) Valid Anagram12345678910111213141516def isAnagram(self, s, t): “”” :type s: str :type t: str :rtype: bool “”” if len(s) != len(t): return False count = collections.defaultdict(int) for c in s: count[c] += 1 for c in t: count[c] -= 1 if count[c] &lt; 0: return False return True defaultdict 就是一个字典，只不过python自动的为它的键赋了一个初始值。这也就是说，你不显示的为字典的键赋初值python不会报错 350. Intersection of Two Arrays II12345678def intersect(self, nums1, nums2): “”” :type nums1: List[int] :type nums2: List[int] :rtype: List[int] “”” a,b = map(collections.Counter,(nums1,nums2)) return list((a&amp;b).elements()) 496. Next Greater Element I123456789101112def nextGreaterElement(self, findNums, nums): “”” :type findNums: List[int] :type nums: List[int] :rtype: List[int] “”” greater,stack = &#123;&#125;,[] for n in nums: while stack and n &gt; stack[-1]: greater[stack.pop()] = n stack.append(n) return [greater[n] if n in greater else -1 for n in findNums] 693. Binary Number with Alternating Bits12s = bin(n) return ’00’ not in s and ’11’ not in s 553. Optimal Division12345678910 def optimalDivision(self, nums): “”” :type nums: List[int] :rtype: str “”” nums = list(map(str, nums)) if len(nums) &gt; 2: nums[1] = “(“ +nums[1] nums[-1] = nums[-1] + “)” return “/“.join(nums) 这里是比较tricky的，最大的除法一定是X1/(X2..Xn) 647. Palindromic Substrings1234567891011def countSubstrings(self, s): “”” :type s: str :rtype: int “”” res = 0 for j in range(len(s) + 1): for i in range(j): if s[i:j] == s[i:j][::-1]: res +=1 return res 226. Invert Binary Tree123456789101112def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack += node.left, node.right return root ```递归方法还是比较简单的，所以只写迭代]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络学习note2]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0note2%2F</url>
    <content type="text"><![CDATA[神经网络学习note2note1和动态规划都被我吃掉了 一些基础知识对一般的监督式学习，使用标准的神经网络模型对图像识别处理问题，使用卷积神经网络（CNN）对类似语音的序列信号，使用循环神经网络（RNN） Structured Data: 有实际意义的数据Unstructured Data：比较抽象的数据 二分类逻辑回归（Logisitic Regression）一般用来解决二分类（Binary Classification）问题逻辑回归的预测输出可以写成：sigmoid函数的意义在于将逻辑回归的输出限定在[0,1]间 损失函数（cost function）：选择的损失函数一般应该是convex的梯度下降：使用梯度下降来计算出合适的w，b值，最小化损失函数 Python机制向量化（Vectorization） 在python中使用向量化要比使用循环计算速度快对于所有m个样本，dZ、db、dw可表示为：Z = np.dot(w.T,X) +bA = sigmoid(Z)dZ = A - Ydw = 1/mnp.dot(X,dZ.T)db = 1/mnp.sum(dZ) w = w - alphadwb = b - alphadb python中的广播机制： 让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐 输出数组的shape是输入数组shape的各个轴上的最大值 如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错 当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值 神经网络的正向传播：输入层到隐藏层，一次逻辑回归运算隐藏层到输出层，一次逻辑回归运算 行表示神经元个数，列表示样本数目m 激活函数（activation function）对于隐藏层，使用tanh函数较好，隐藏层的输出被限定在[-1,1]间，在0值附近分布，均值为0，这样从隐藏层到输出层，数据起到了归一化的效果。当|z|很大时，sigmoid和tanh函数的斜率都很小，梯度下降算法的速度会变慢，所以出现了ReLu函数。 反向传播：w[1]和w[2]都不能初始化为零，若初始化为零迭代更新会得到同样的结果 深层神经网络就是包含更多隐藏层的神经网络对于第l层，正向传播过程可以表示为：维度分别为：]]></content>
      <categories>
        <category>ng课程笔记</category>
      </categories>
      <tags>
        <tag>NN</tag>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（七）]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（七）明天重点看看动态规划问题 543. Diameter of Binary Tree123456789101112131415def diameterOfBinaryTree(self, root): “”” :type root: TreeNode :rtype: int “”” self.ans = 0 def depth(node): if not node: return 0 anL, anR = depth(node.right), depth(node.left) self.ans = max(self.ans, anL+anR) return 1+max(anL, anR) depth(root) return self.ans 540. Single Element in a Sorted Array12345678910111213def singleNonDuplicate(self, nums): “”” :type nums: List[int] :rtype: int “”” left, right = 0, len(nums)-1 while left &lt; right: mid = (left + right)/2 if nums[mid] == nums[mid+1]: right = mid + 1 else: left = mid return nums[left] 然鹅超时了……不过先这样写着吧 198. House Robber12345678910 def rob(self, nums): “”” :type nums: List[int] :rtype: int “”” i, j = 0, 0 for m in nums: k, i = i, m + j j = max(k, j) return max(i, j) f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 104. Maximum Depth of Binary Tree12345678def maxDepth(self, root): “”” :type root: TreeNode :rtype: int “”” if not root: return 0 return 1+max(self.maxDepth(root.left), self.maxDepth(root.right))]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（六）]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（六）应该是上周刷的题一直忘记发了 763. Partition Labels1234567891011121314class Solution(object): def partitionLabels(self, S): “”” :type S: str :rtype: List[int] “”” size = [] while S: I = 1 while set(S[I:])&amp;set(S[:I]): I+=1 size.append(i) S=S[I:] return size 806. Number of Lines To Write String123456789101112def numberOfLines(self, widths, S): “”” :type widths: List[int] :type S: str :rtype: List[int] “”” res, cur = 1, 0 for I in S: width = widths[ord(i) - ord(‘a’)] res += 1 if cur + width &gt; 100 else 0 cur = width if cur +width &gt; 100 else cur + width return [res, cur] 537. Complex Number Multiplication12345678def complexNumberMultiply(self, a, b): “”” :type a: str :type b: str :rtype: str “”” a, ai, b, bi = map(int, re.findall(‘-?\d+’, a+b)) return ‘%d+%di’ % (a*b - ai*bi, a*bi + ai*b) 419. Battleships in a Board12345678910111213141516def countBattleships(self, board): “”” :type board: List[List[str]] :rtype: int “”” total = 0 for I in range(len(board)): for j in range(len(board[0])): if board[I][j] == ‘X’: flag = 1 if j&gt;0 and board[I][j-1] == ‘X’: flag = 0 if I&gt;0 and board[i-1][j] == ‘X’: flag = 0 total += flag return total 821. Shortest Distance to a Character1234567### def shortestToChar(self, S, C):### “””### :type S: str### :type C: str### :rtype: List[int]### “””### return [min(abs(I - j) for j, e in enumerate(S) if e == C) for I in range(len(S))] 530.Minimum Absolute Difference in BST12345678910111213def getMinimumDifference(self, root): “”” :type root: TreeNode :rtype: int “”” def dsf(node, l = []): if node.left: dsf(node.left, l) l.append(node.val) if node.right: dsf(node.right, l) return l l = [1,2,3,4,5] return zip(l,l[1:]) 669. Trim a Binary Search Tree12345678910111213141516 def trimBST(self, root, L, R): “”” :type root: TreeNode :type L: int :type R: int :rtype: TreeNode “”” if not root: return None if L &gt; root.val: return self.trimBST(root.right, L, R) elif R &lt; root.val: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root 513. Find Bottom Left Tree Value123456789def findBottomLeftValue(self, root): “”” :type root: TreeNode :rtype: int “”” q = [root] for node in q: q+=filter(None, (node.right, node.left)) return q 637. Average of Levels in Binary Tree12345678910def dfs(node, depth = 0): if node: if len(info) &lt;= depth: info.append([0,0]) info[depth][0] += node.val info[depth][1] += 1 dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root) return [s/float(c) for s,c in info]]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（五）]]></title>
    <url>%2F2018%2F05%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（五）噗 797. All Paths From Source to Target12345678def allPathsSourceTarget(self, graph): def dfs(cur, path): if cur == len(graph) - 1: res.append(path) else: for i in graph[cur]: dfs(i, path + [i]) res = [] dfs(0, [0]) return res 617.Merge Two Binary TreesGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.12345678910111213def mergeTrees(self, t1, t2): &quot;&quot;&quot; :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode &quot;&quot;&quot; if t1 and t2: root = TreeNode(t1.val+t2.val) root.left = self.mergeTrees(t1.left,t2.left) root.right = self.mergeTrees(t1.right,t2.right) return root else: return t1 or t2 728.Self Dividing Numbers12is_self_dividing = lambda num: &apos;0&apos; not in str(num) and all(num % int(digit) == 0 for digit in str(num)) return filter(is_self_dividing, range(left, right + 1)) Subdomain Visit Count123456789101112131415161718def subdomainVisits(self, cpdomains): &quot;&quot;&quot; :type cpdomains: List[str] :rtype: List[str] &quot;&quot;&quot; visits, res = &#123;&#125;, [] for domain in cpdomains: tmp = domain.split() count, doms = int(tmp[0]), tmp[1].split(&apos;.&apos;) for i in range(len(doms)): domain = &apos;.&apos;.join(doms[i:]) if visits.get(domain, 0): visits[domain] += count else: visits[domain] = count for v in visits.items(): res.append(str(v[1]) + &apos; &apos; + v[0]) return res 814.Binary Tree Pruning123456789class Solution: def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root root.left, root.right = self.pruneTree(root.left), self.pruneTree(root.right) return root if root.val == 1 or root.left or root.right else None 要认真学习啊！没有买到优衣库的T恤qwq]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（四）]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（四）链表 237.Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.12345678class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 725.Split Linked List in Parts1234567891011121314151617181920def splitListToParts(self, root, k): &quot;&quot;&quot; :type root: ListNode :type k: int :rtype: List[ListNode] &quot;&quot;&quot; curr, length = root, 0 while curr: curr, length = curr.next, length + 1 chunk, longer = length//k, length%k res = [chunk + 1]*longer + [chunk]*(k-longer) prev, curr = None, root for index, num in enumerate(res): if prev: prev.next = None res[index] = curr for i in range(num): prev, curr = curr, curr.next return res 分三步：求长度，切块，把数据装进去 206.Reverse Linked List迭代不太懂id……12345678def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev 递归123456789def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 445.Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.123456789101112131415161718192021222324def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if not l1: return l2 if not l2: return l1 x1 = x2 = &apos;&apos; while l1: x1 += str(l1.val) l1 = l1.next while l2: x2 += str(l2.val) l2 = l2.next y = int(x1)+int(x2) y = str(y) head = next_node = ListNode(y[0]) for i in range(1, len(y)): next_node.next = ListNode(y[i]) next_node = next_node.next return head 328.Odd Even Linked List1234567891011121314151617def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; d1=odd=ListNode(0) d2=even=ListNode(0) i=1 while head: if i%2: odd.next,odd=head,head else: even.next,even=head,head head=head.next i+=1 odd.next,even.next=d2.next,None return d1.next 放五一了啦啦啦]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（三）]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（三）今天除了数组部分，再写一点链表吧( ̀⌄ ́) 695.Max Area of IslandGiven a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.1234567891011def maxAreaOfIsland(self, grid): m, n = len(grid), len(grid[0]) def dfs(i, j): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j]: grid[i][j] = 0 return 1 + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i + 1, j) + dfs(i, j - 1) return 0 areas = [dfs(i, j) for i in range(m) for j in range(n) if grid[i][j]] return max(areas) if areas else 0 283.Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.12345678def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for i in range(nums.count(0)): nums.remove(0) nums.append(0) 另一种方法：123456def moveZeroes(self, nums): zero = 0 # records the position of &quot;0&quot; for i in xrange(len(nums)): if nums[i] != 0: nums[i], nums[zero] = nums[zero], nums[i] zero += 1 667.Beautiful Arrangement II简单来说就是给[n,k], 生成一个list，其中有n个正整数，正整数相减后的绝对值的结果有k个正整数。1234567891011121314a = [1]h = k+1l = 2for _k in range(k,0,-2): if _k == 1: a.append(h) break else: a.append(h) a.append(l) h -= 1 l += 1a.extend(range(k+2,n+1))return a 495.Teemo Attacking12345678910def findPoisonedDuration(self, tS, d): &quot;&quot;&quot; :type timeSeries: List[int] :type duration: int :rtype: int &quot;&quot;&quot; ans = len(tS)*d for i in range(1, len(tS)): ans -= max(0, d-tS[i]+tS[i-1]) return ans 448. Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.12def findDisappearedNumbers(self, nums): return list(set([i for i in range(1,len(nums)+1)]).difference(set(nums))) 另外一种标记的方法：12345for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] &gt; 0] 挺机智的…… 817.Linked List Components12345678910111213def numComponents(self, head, G): &quot;&quot;&quot; :type head: ListNode :type G: List[int] :rtype: int &quot;&quot;&quot; setG = set(G) res = 0 while head: if head.val in setG and (head.next == None or head.next.val not in setG): res += 1 head = head.next return res 不能沉迷塞尔达，要学习]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近看的区块链知识的小记录]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[1.区块链的定义区块链是以比特币为代表的数字加密货币体系 的核心支撑技术. 区块链技术的核心优势是去中心化, 能够通过运用数据加密、时间戳、分布式共识和经济激励等手段, 在节点无需互相信任的分布式系统中实现基于去中心化信用的点对点交易、协调与协作, 从而为解决中心化机构普遍存在的高成本、低效率和数据存储不安全等问题提供了解决方案。特点：去中心化、时序数据、集体维护、可编程和安全可信 区块链的基础架构模型 数据层：封装底层数据区块以及相关的数据加密和时间戳等技术 网络层：包括分布式组网机制、数据传播机制和数据验证机制等 共识层：封装网络节点的各类共识算法 激励层：将经济因素集成到区块链技术体系中，主要包括经济激励的发行机制和分配机制 合约层：封装各类脚本、算法和智能合约 应用层：区块链的各种应用场景和案例 上图为数据区块的结构，分为区块头和区块体两部分。最先找到正确的解随机数Nonce并经过全体矿工验证的矿工会获得当前区块的记帐权，获得记帐权的矿工将当前区块链接到前一区块，形成最新的区块主链。 2.区块链的分类公共链公共链对外公开，用户不用注册就能匿名参与，无需授权即可访问网络和区块链，是真正意义上的完全去中心化的区块链，如比特币和以太坊 以太坊以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。以太坊是个平台和编程语言，包括数字货币和用来构建和帆布分布式应用的以太脚本，是区块链与智能合约的完美结合，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。 编程语言：Solidity以太坊具有4种专用语言：Serpent（长得像Python）、Solidity（JS）、Mutan（Go）和LLL（Lisp）智能合约的默认的编程语言是Solidity，文件扩展名以.sol结尾。Solidity是和JavaScript相似的语言，用它来开发合约并编译成以太坊虚拟机字节代码。 运行环境：EVMEVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。EVM是由许多互相连接的计算机组成的。任何人都可以为所有权、交易格式和状态转化函数创建商业逻辑。 以太坊账户以太坊内有两类账户。外部账户被公钥-私钥对控制，合约账户被存储在账户中的代码控制。外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取写入发送其他消息和创建合约。 Gas以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。 以太坊客户端目前有Go语言实现的客户端Geth，用C++实现的客户端Eth，Python实现的客户端Pyethapp和Java实现的客户端EthereumJ。以太坊包括一个专用的客户端浏览器，使得用户可以运行各种各样的去中心化应用（DApp），发布智能合约，这一类浏览器被称为Mist。Mist由特殊的安全层、密匙管理、去中心化账户管理和与区块链相关的组件几部分组成。从用户体验角度而言，可以在Mist中使用DApp，就像通过常规浏览器与网站进行交互一样。 应用Augur（Augur - Home）一个去中心化预测系统Maker（MakerDAO - Stability for the blockchain）一个金融类去中心化自治组织 联盟链联盟链仅限于联盟成员参与，区块链上的读写权限、参与记账权限按照联盟规则来制定，如区块链联盟R3和超级账本（hyperleder）。 超级账本（ Hyperledger）超级账本项目是由Linux基金会于2015年12月启动的开源项目，旨在推动各方协作，共同打造机遇区块链的企业级分布式账本底层技术，用于构建支撑业务的行业应用和平台。超级账本是由大企业领衔的商业化联盟链项目。 项目管理形式理事会：负责日常事务管理，包括审核预算、监督项目和市场活动、表决重要事项等职责。技术指导委员会：项目的贡献者或维护者选举产生，主要任务是在技术上保证项目正常进行，包括制定技术方向、审批项目议案等。任何贡献代码、文档等技术性产品的人都可以称为贡献者。市场委员会用户顾问团 FabricFabric为应用提供了gRPC API，以及封装API的SDK供应用调用。应用可以通过SDK访问Fabric网络中的多种资源，包括账本、交易、链码、事件、权限管理等。应用开发者只需要跟这些资源打交道即可，无需关心如何实现。其中，账本是最核心的结构，记录应用信息，应用则通过发起交易来向账本中记录数据。交易执行的逻辑通过链码来承载。整个网络运行中发生的事件可以被应用访问，以触发外部流程甚至其他系统。权限管理则负责整个过程中的访问控制。账本和交易进一步地依赖核心的区块链结构、数据库、共识机制等技术；链码则依赖容器、状态机等技术；权限管理利用了已有的PKI体系、数字证书、加解密算法等诸多安全技术。底层由多个节点组成P2P网络，通过gRPC通道进行交互，利用Gossip协议进行同步。Fabric侧重于权限控制、私密性保护和交易性能提高。 Sawtooth Lake这个工程称为”锯齿湖”，对于创建，部署和运行分布式账本来说它是一个高度模块化平台的工程，分布式账本提供数据记录维护一个去中心化权威和实现。代替单个集中式数据库，分布式帐本中的参与者为共享计算贡献资源，确保对分布式帐本的状态的普遍一致。比特币是最流行的分布式分帐本，该技术已经被提议用于国际汇款，保险索赔处理，供应链管理和物联网（IoT）的许多不同的应用场景。在锯齿湖项目中的分布式账本包括3个组件：代表账本状态的数据模型；改变账本状态的交易语言；在参与者之间建立交易结果共识的协议。锯齿湖侧重于提供完整的交易家族和节能的共识算法。Fabric和Sawtooth都提供了分布式账本的实现。 IrohaIroha可以完善Fabric、锯齿湖和其他有潜力的项目，通过用C++创造可重复使用的要素，能被GO一类的语言编译。通过这种方法，Iroha能融入现有项目，其长期目标是实现一个健全资源库，超级账本技术项目在运行分布式账本时，能自由地选择并使用这些可重复使用的元素。尽管通过java（运行JVM沙盒）的chaincode完善智能合约也是可行的，但Iroha的用户不需要写chaincode来确定数字资产。使用货币和发短信这样的普通场景也是核心构架的一部分。 BurrowBurrow是一种从以太坊衍生出来的代码库，灵感来自于Monax在2014年开发和开源的一种叫做eris-db的技术。该项目由英特尔和Monax提出，为商业公司和组织提供了一个智能合约平台。 依托以太坊强大的开发框架和灵活的去中心化应用生态系统，Burrow将会提供一种必要的基础设施给那些寻求利用基于区块链的智能合约用于商业运营的企业和超级账本成员。 私有链私有链仅在私有组织使用，区块链上的读写权限、参与记账权限按私有组织规则制定，一般是企业内部的应用。 侧链能和比特币区块链交互，并与比特币挂钩的区块链。比特币是大家公认的公共链，但规则相对固定，交易速度较慢，所以通过侧链提高效率是一个有效做法。 互联链针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种互联互通协议连接起来，形成区块链全球网络 3.基于比特币的方案闪电网络闪电网络（Lightning Network）是一个去中心化的系统。闪电网络的卓越之处在于，无需信任对方以及第三方即可实现实时的、海量的交易网络。它利用了了比特币的安全特性，在线下提供高速的实时交易处理能力。用户既可以通过点对点的直接支付方式，也可以通过网络路由的方式实现间接支付。闪电网络的关键技术有三，后后依赖于前前，依次是：RSMC，HTLC和闪电网络。技术实现虽然复杂，但本质却很简单。RSMC：闪电网络的基础是交易双方之间的双向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定义了该双向微支付通道的最基本工作方式。HTLC： RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。RSMC通过巧妙的设置Commitment TX的多重签名输出，以及sequence的延迟进块形成惩罚窗口期，解决了在微支付通道中的币单向流动问题。 雷电网络RAIDEN网络是一个离链规模的解决方案，使近即时，低费用和可扩展的支付。是以太坊社区提出的链下微支付通道解决方案。A向D转账，经由B和C的支付通道中介。A构造由secret解锁的哈希锁向B转账，由B和C按同样的secret解锁条件依次构造向C和D的哈希锁转账。然后A向D提供解锁的secret。D向C出示secret，拿到哈希锁转账中被锁定的代币，并得到C向D转账的余额证明。最后C和B重复此操作。交易双方只要在链上存在交易通道，就能在链下基于被锁定的余额进行高频、双向的即时确认交易。多个通道形成的支付路径构成“雷电网络”。 4.总结这几天阅读了一些博客和《区块链技术指南》，了解到区块链的一些应用。区块链目前呼声很高，炙手可热，希望以后能有更加深入的学习。 以太坊是什么 - 以太坊开发入门指南 - Tiny熊 - 博客园袁勇, &amp; 王飞跃. (2016). 区块链技术发展现状与展望. 自动化学报, 42(4), 481-494.超级账本Fabric的架构与设计 - CSDN博客Fabric · GitHubhttps://github.com/hyperledger区块链技术指南.邹均详解最近大热的闪电网络、雷电网络和CORDA巴比特服务于区块链创新者闪电网络和雷电网络详解GitHub - raiden-network/raiden: Raiden Network]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录(二)]]></title>
    <url>%2F2018%2F04%2F20%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（二）看书看到数组今天就刷下数组吧。今天上网页编程课学JS也是一言难尽…… 561.Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) list.sort()在python3里只有key和reverse两个参数了。 566.Reshape the MatrixYou’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.第一种用numpy的方法：1234567891011def matrixReshape(self, nums, r, c): &quot;&quot;&quot; :type nums: List[List[int]] :type r: int :type c: int :rtype: List[List[int]] &quot;&quot;&quot; try: return np.reshape(nums,(r,c)).tolist() except: return nums 第二种123456def matrixReshape(self, nums, r, c): flat = sum(nums, []) if len(flat) != r * c: return nums tuples = zip(*([iter(flat)] * c)) return map(list, tuples) 766.Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.123456def isToeplitzMatrix(self, m): for i in range(len(m)-1): for j in range(len(m[0])-1): if m[i][j] != m[i+1][j+1]: return False return True 485.Max Consecutive Ones1234567891011def findMaxConsecutiveOnes(self, nums): maxc = 0 count = 0 for i in nums: if i == 1: count = count +1 else: maxc = max(maxc, count) count = 0 maxc = max(maxc, count) return maxc 这道题想过将list转str，但是感觉会很慢而且没有写出来 ( ´▽｀)想吃螺狮粉]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录(一)]]></title>
    <url>%2F2018%2F04%2F17%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（一）为了加强基础决定刷题，从leetcode的简单开始，也是对数据结构的复习巩固。 557.Reverse Words in a String IIIGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. 12def reverseWords(self, s): return &apos; &apos;.join(i[::-1] for i in s.split()) 另外在讨论区看到一种解决方案：12def reverseWords(self, s): return &apos; &apos;.join(s.split()[::-1])[::-1] 344. Reverse StringWrite a function that takes a string as input and returns the string reversed.12def reverseString(self, s): return s[::-1] 819.Most Common Word1234567891011from collections import Counterimport reclass Solution(object): def mostCommonWord(self, paragraph, banned): words = Counter(re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, paragraph).lower().split()) ban = set(banned) for i in ban: if i in words: del words[i] words = words.most_common() return (words)[0][0] PS.12345def mostCommonWord(self, p, banned): words = re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, p).lower().split() res = collections.Counter(words).most_common() ban = set(banned) return iter(w for w, n in res if w not in ban).next() iter()函数获取迭代器，对获取到的迭代器使用next()函数来获取下一条数据 刚开始刷题比较难了，希望以后能够更熟练吧]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
