<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåä¹ï¼‰]]></title>
    <url>%2F2019%2F07%2F13%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[leetcodeåˆ·é¢˜è®°å½•(åä¹)392.Is Subsequencetwo pointers12345i,j = 0,0 while i&lt;len(s) and j &lt; len(t): if s[i] == t[j]: i+=1 j += 1 return True if i==len(s) else False ç”¨é˜Ÿåˆ—çš„æ–¹æ³•ï¼Œæœ€åŽåˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º123456queue = collections.deque(s) for c in t: if not queue: return True if c == queue[0]: queue.popleft() return not queue 236.Lowest Common Ancestor of a Binary Tree1234567891011if root==p or root==q: return root left = right = None if root.left: left=self.lowestCommonAncestor(root.left,p,q) if root.right: right=self.lowestCommonAncestor(root.right,p,q) if left and right: return root else: return left or right 852.Peak Index in a Mountain Array12345678l,r = 0, len(A)-1 while l&lt;r: m = (l+r)/2 if A[m] &lt; A[m+1]: l = m+1 else: r = m return l 368.Largest Divisible Subsetsortæ•°ç»„ï¼Œå½“nums[j]%nums[i]==0çš„æ—¶å€™å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹dp[i] = max(dp[i], dp[j]+1)ï¼Œå…¶å®žå°±æ˜¯æ‰¾å‡ºæœ€é•¿é“¾ã€‚123456789101112131415161718192021222324n = len(nums) if n==0 or n==1: return nums nums = sorted(nums) dp = [0]*n max,max_index = 0,0 child = [0]*n res = [] for i in range(n-1,-1,-1): for j in range(i,n): if nums[j]%nums[i] == 0 and dp[i]&lt;dp[j]+1: dp[i] = dp[j]+1 child[i] = j if max &lt; dp[i]: max = dp[i] max_index = i i = max_index for j in range(max): res.append(nums[i]) i = child[i] return res 890.Find and Replace Patternset+dict, æ˜ å°„æ¨¡å¼12345678910111213141516ans = [] set_p =set(pattern) for word in words: if len(set(word)) != len(set_p): continue fx = dict() equal = True for i,w in enumerate(word): if w in fx: if fx[w] != pattern[i]: equal = False break fx[w] = pattern[i] if equal: ans.append(word) return ans åªç”¨å­—å…¸12345def findAndReplacePattern(self, words, pattern): def F(w): m = &#123;&#125; return [m.setdefault(c,len(m)) for c in w] return [w for w in words if F(w)==F(pattern)] 210.Course Schedule IIä½¿ç”¨ä¸€ä¸ªvisitedæ•°ç»„ï¼Œå½“visited[i]å€¼ä¸º0ï¼Œè¯´æ˜Žè¿˜æ²¡åˆ¤æ–­è¿™ä¸ªç‚¹ï¼›å½“visited[i]å€¼ä¸º1ï¼Œè¯´æ˜Žå½“å‰çš„å¾ªçŽ¯æ­£åœ¨åˆ¤æ–­è¿™ä¸ªç‚¹ï¼›å½“visited[i]å€¼ä¸º2ï¼Œè¯´æ˜Žå·²ç»åˆ¤æ–­è¿‡è¿™ä¸ªç‚¹ï¼Œå«ä¹‰æ˜¯ä»Žè¿™ä¸ªç‚¹å¾€åŽçš„æ‰€æœ‰è·¯å¾„éƒ½æ²¡æœ‰çŽ¯ï¼Œè®¤ä¸ºè¿™ä¸ªç‚¹æ˜¯å®‰å…¨çš„ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬å¯¹æ¯ä¸ªç‚¹å‡ºå‘éƒ½åšè¿™ä¸ªåˆ¤æ–­ï¼Œæ£€æŸ¥è¿™ä¸ªç‚¹å‡ºå‘çš„æ‰€æœ‰è·¯å¾„ä¸Šæ˜¯å¦æœ‰çŽ¯ï¼Œå¦‚æžœåˆ¤æ–­è¿‡ç¨‹ä¸­æ‰¾åˆ°äº†å½“å‰çš„æ­£åœ¨åˆ¤æ–­çš„è·¯å¾„ï¼Œè¯´æ˜Žæœ‰çŽ¯ï¼›æ‰¾åˆ°äº†å·²ç»åˆ¤æ–­æ­£å¸¸çš„ç‚¹ï¼Œè¯´æ˜Žå¾€åŽéƒ½ä¸å¯èƒ½å­˜åœ¨çŽ¯ï¼Œæ‰€ä»¥è®¤ä¸ºå½“å‰çš„èŠ‚ç‚¹ä¹Ÿæ˜¯å®‰å…¨çš„ã€‚123456789101112131415161718192021def findOrder(self, numCourses, prerequisites): graph = collections.defaultdict(list) for u,v in prerequisites: graph[u].append(v) visited = [0]*numCourses path = [] for i in range(numCourses): if not self.dfs(graph,visited,i,path): return [] return path def dfs(self,graph,visited,i,path): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph,visited,j,path): return False visited[i] = 2 path.append(i) return True 547.Friend Circles123456789c = collections.Counter(hand) for i in sorted(c): if c[i] &gt; 0: cur = c[i] for j in range(W): c[i+j] -= cur if c[i+j]&lt;0: return False return True 475.Heatersradiuså­˜å‚¨æœ€å¤§åŠå¾„ï¼Œå¯¹äºŽæ¯ä¸ªæˆ¿å­ï¼Œè¦ä¸å°±æ˜¯å‰é¢çš„heaterä¾›æš–ï¼Œè¦ä¸å°±æ˜¯åŽé¢çš„heaterï¼Œæ‰€ä»¥åªéœ€è¦æ‰¾å‡ºè¿™ä¸¤ä¸ªä¹‹é—´çš„æœ€å°å€¼å’Œradiusæ¯”è¾ƒï¼Œç‰¹æ®Šæƒ…å†µæ˜¯å‰é¢æˆ–è€…åŽé¢æ²¡æœ‰heaterã€‚12345678910111213heaters = sorted(heaters) houses = sorted(houses) i = radius = 0 for house in houses: while i &lt; len(heaters) and heaters[i] &lt; house: i +=1 if i == 0: radius = max(radius, heaters[i] - house) elif i == len(heaters): return max(radius, houses[-1] - heaters[-1]) else: radius = max(radius, min(heaters[i]-house,house-heaters[i-1])) return radius 621.Task Scheduleræ‰¾å‡ºæ•°é‡æœ€å¤šçš„ä»»åŠ¡ï¼Œç„¶åŽæ’ç©º1234task_counts = collections.Counter(tasks).values() m = max(task_counts) m1 = task_counts.count(m) return max(len(tasks), (m-1)*(n+1)+m1) 454.4Sum IIä¸€ä¸ªæ¯”è¾ƒæ…¢çš„æ–¹æ³•ï¼Œæœ¬è´¨hashmap12AB = collections.Counter(a+b for a in A for b in B) return sum(AB[-c-d] for c in C for d in D) 230.Kth Smallest Element in a BSTæ™®é€šéåŽ†12345678910def kthSmallest(self, root: TreeNode, k: int) -&gt; int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k==0: return root.val root = root.right 658.Find K Closest Elementstwo pointersï¼Œä»Žä¸¤ç«¯å¼€å§‹ï¼Œå¼¹å‡ºæ¯”è¾ƒè¿œçš„é‚£ä¸ªã€‚123456while len(arr) &gt; k: if x-arr[0] &lt;= arr[-1]-x: arr.pop() else: arr.pop(0) return arr è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾ï¼Œå•Šæˆ‘çš„ç†è§£æ˜¯ï¼Œæ¯”è¾ƒä¸¤ç«¯å’Œxçš„è·ç¦»ï¼Œå“ªè¾¹å°å°±å¾€å“ªè¾¹èµ°ï¼Œå°±å¾ˆç¥žå¥‡ã€‚123456789l = 0 r = len(arr) -k while l&lt;r: mid = l + (r-l)/2 if x - arr[mid] &gt; arr[mid+k] - x: l = mid+1 else: r = mid return arr[l:l+k] 263.Ugly Numberè¿™é“é¢˜æ˜¯easyéš¾åº¦çš„ï¼Œç›´æŽ¥å†™1234if num &lt;= 0: return False for x in (2,3,5): while num % x == 0: num=num/x return num == 1 130.Surrounded Regionsæ‰¾å‡ºè¾¹ç•Œçš„Oï¼Œå¯¹ä»–ä»¬è¿›è¡ŒbfsæŸ¥æ‰¾æ‰¾å‡ºç›¸é‚»çš„Oï¼Œè½¬åŒ–ä¸ºDï¼Œç„¶åŽæŠŠå‰©ä¸‹çš„Oæ”¹ä¸ºXï¼ŒDæ”¹æˆOã€‚å¥½åƒå¯ä»¥ç”¨å¹¶æŸ¥é›†ã€‚12345678910111213141516171819202122if not board: return row, col = len(board), len(board[0]) q = collections.deque() for r in range(row): for c in range(col): if r in [0, row-1] or c in [0, col-1] and board[r][c]==&apos;O&apos;: q.append((r,c)) while q: x, y = q.popleft() if 0 &lt;= x &lt; row and 0 &lt;= y &lt; col and board[x][y] == &apos;O&apos;: board[x][y] = &apos;D&apos; for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]: q.append((x+dx, y+dy)) for r in range(row): for c in range(col): if board[r][c] == &apos;O&apos;: board[r][c] = &apos;X&apos; elif board[r][c] == &apos;D&apos;: board[r][c] = &apos;O&apos; 1008.Construct Binary Search Tree from Preorder Traversalè¿”å›žä¸Žç»™å®šå…ˆåºéåŽ†ç›¸åŒ¹é…çš„äºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹ï¼ŒäºŒå‰æœç´¢æ ‘å³å³å­æ ‘&gt;æ ¹èŠ‚ç‚¹&gt;å·¦å­æ ‘ï¼Œå°±å†™å‘—123456789i = 0 def bstFromPreorder(self, preorder, bound = float(&apos;inf&apos;)): if self.i == len(preorder) or preorder[self.i] &gt; bound: return None root = TreeNode(preorder[self.i]) self.i += 1 root.left = self.bstFromPreorder(preorder,root.val) root.right = self.bstFromPreorder(preorder,bound) return root 763.Partition Labelsè¿™ä¸ªä»¥å‰åšè¿‡ï¼Œä¹‹å‰çš„æ–¹æ³•æ˜¯ç”¨setï¼ŒçŽ°åœ¨ç”¨two pointersé¦–å…ˆç”¨å­—å…¸ä¿å­˜æ¯ä¸ªå…ƒç´ æœ€é å³çš„indexï¼Œç„¶åŽéåŽ†Sï¼Œå¦‚æžœå³æŒ‡é’ˆå’Œæœ€é å³çš„æŒ‡é’ˆç›¸åŒï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ä¸ªsectionçš„ç»“æŸï¼Œç”¨å·¦æŒ‡é’ˆæ ‡è®°sectionçš„å¼€å§‹ã€‚12345678910rmax = &#123;c: i for i, c in enumerate(S)&#125; l,r = 0,0 res = [] for i, letter in enumerate(S): r = max(r, rmax[letter]) if i==r: res += [r-l+1] l = i+1 return res 209.Minimum Size Subarray Sumè¿˜æ˜¯two pointers12345678910if sum(nums) &lt; s: return 0 res = len(nums) l, total = 0,0 for i,n in enumerate(nums): total += n while total &gt;= s: res = min(res, i-l+1) total -= nums[l] l += 1 return res 938.Range Sum of BST1234567891011self.sum = 0 def mid(root): if root.left: mid(root.left) if root.val&gt;=L and root.val&lt;=R: self.sum += root.val if root.right: mid(root.right) if root: mid(root) return self.sum]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåå…«ï¼‰]]></title>
    <url>%2F2019%2F06%2F25%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[leetcodeåˆ·é¢˜è®°å½•(åå…«)845.Longest Mountain in Array12345678res = up = down = 0 for i in range(1,len(A)): if down and A[i-1] &lt; A[i] or A[i-1] == A[i]: up = down = 0 up += A[i-1] &lt; A[i] down += A[i-1] &gt; A[i] if up and down: res = max(res,up+down+1) return res 893.Groups of Special-Equivalent Strings123456B = set() for string in A: C = list(string) a,b = C[::2],C[1::2] B.add((&apos;&apos;.join(sorted(a)),&apos;&apos;.join(sorted(b)))) return len(B) 905.Sort Array By Parity12345678s,e = 0,len(A) - 1 while s &lt; e: while A[s]%2 == 0 and s &lt; e: s += 1 while A[e]%2 == 1 and s &lt; e: e -= 1 A[s], A[e] = A[e],A[s] return A 926.Flip String to Monotone Increasing1234567891011n = len(s) cnt0 = s.count(&apos;0&apos;) cnt1 = 0 res = n - cnt0 for i in range(n): if s[i] == &apos;0&apos;: cnt0 -= 1 elif s[i] == &apos;1&apos;: res = min(res,cnt1+cnt0) cnt1 += 1 return res 739.Daily Temperatures1234567891011n = len(T)res = [0]*nfor i in range(n-2,-1,-1): k = i+1 while T[i] &gt;= T[k] and res[k]&gt;0: k += res[k] if T[k] &gt; T[i]: res[i] = k-ireturn res 42.Trapping Rain Water1234567891011left = right = water = 0 i,j = 0,len(height)-1 while i&lt;=j : left,right = max(left,height[i]),max(right,height[j]) while i&lt;=j and height[i] &lt;=left &lt;= right: water += left - height[i] i += 1 while i&lt;=j and height[j] &lt;=right &lt;= left: water += right - height[j] j -= 1 return water 114.Flatten Binary Tree to Linked List1234567891011if not root: return right = root.right if root.left: self.flatten(root.left) tail = root.left while tail.right: tail = tail.right root.left,root.right,tail.right = None, root.left,right self.flatten(right) 896.Monotonic Array1234567891011121314n = len(A) if n &lt; 2: return True a = b = False for i in range(1,n): if A[i] &gt; A[i-1]: a = True if A[i] &lt; A[i-1]: b = True if a and b: return False return True Plus One12345678910length = len(digits) - 1 res = list(digits) while res[length] == 9: res[length] = 0 length -= 1 if (length &lt; 0): res = [1] + res else: res[length] += 1 return res another way1234567res = [] sd = &apos;&apos;.join(str(i) for i in digits) ids = int(sd) + 1 sd = str(ids) for i in sd: res.append(int(i)) return res Valid Sudoku1234567891011big = set() for i in xrange(0,9): for j in xrange(0,9): if board[i][j] != &apos;.&apos;: cur = board[i][j] if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big: return False big.add((i,cur)) big.add((cur,j)) big.add((i/3,j/3,cur)) return True 841.Keys and RoomséåŽ†ä¸€éï¼Œç„¶åŽçœ‹èƒ½åŽ»çš„æˆ¿é—´æ˜¯ä¸æ˜¯æ‰€æœ‰æˆ¿é—´123456789visited = [0] * len(rooms) self.dfs(rooms, 0, visited) return sum(visited) == len(rooms) def dfs(self, rooms, index, visited): visited[index] = 1 for key in rooms[index]: if not visited[key]: self.dfs(rooms, key, visited) 946.Validate Stack Sequenceså°±å†™å‘—1234567891011stack, n = [], len(pushed) p = 0 for i in range(n): if stack and popped[i] == stack[-1]: stack.pop() else: while p&lt;n and pushed[p] != popped[i]: stack.append(pushed[p]) p += 1 p += 1 return not stack 655.Print Binary Tree1234567891011121314if not root: return [&quot;&quot;] def getDepth(root): if not root: return 0 return 1 + max(getDepth(root.left), getDepth(root.right)) d = getDepth(root) cols = 2**d -1 self.res = [[&quot;&quot; for i in range(cols)] for j in range(d)] def helper(root, d, pos): self.res[-d - 1][pos] = str(root.val) if root.left: helper(root.left, d - 1, pos - 2 ** (d - 1)) if root.right: helper(root.right, d - 1, pos + 2 ** (d - 1)) helper(root, d-1, 2**(d-1) -1) return self.res 809.Expressive Wordsè€ƒè™‘åˆ°ä¸¤ä¸ªæƒ…å†µï¼š1 å•ä¸ªletteræ•°å°äºŽ3ï¼Œé‚£ä¹ˆletteråº”è¯¥å’Œwordsä¸­çš„å•è¯ç›¸åŒ2 å¦‚æžœå¤§äºŽæˆ–ç­‰äºŽ3ï¼Œé‚£ä¹ˆletterå°±æ˜¯è¿žç»­çš„123456789101112def expressiveWords(self, S, words): return sum(self.check(S,W) for W in words) def check(self, S, W): i,j,i2,j2,n,m = 0,0,0,0,len(S),len(W) while i&lt;n and j&lt;m: if S[i] != W[j]: return False while i2&lt;n and S[i2] == S[i]: i2+=1 while j2&lt;m and W[j2] == W[j]: j2+=1 if i2-i != j2-j and i2 - i &lt; max(3,j2-j): return False i,j = i2,j2 return i==n and j==m 844.Backspace String Compare123456789def helper(s): res = [] for c in s: if c != &apos;#&apos;: res.append(c) else: res = res[:-1] return res return helper(S) == helper(T)]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåä¸ƒï¼‰]]></title>
    <url>%2F2019%2F04%2F14%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[leetcodeåˆ·é¢˜è®°å½•(åä¸ƒ)96.Unique Binary Search Trees123456arr = [0]*(n+1) arr[0] = 1 for i in range(1, n+1): for j in range(1, i+1): arr[i] += arr[j-1] * arr[i-j] return arr[-1] 200.Number of Islands1234567def dfs(i,j): if 0&lt;=i&lt;len(grid) and 0&lt;=j&lt;len(grid[i]) and grid[i][j] == &apos;1&apos;: grid[i][j] = &apos;0&apos; map(dfs,(i+1,i-1,i,i),(j,j,j+1,j-1)) return 1 return 0 return sum(dfs(i,j) for i in range(len(grid)) for j in range(len(grid[i]))) 199.Binary Tree Right Side View12345ans,level = [],[root] while root and level: ans.append(level[-1].val) level = [k for n in level for k in (n.left,n.right) if k] return ans 166.Fraction to Recurring Decimal123456789101112n,remainder = divmod(abs(numerator),abs(denominator)) sign = &apos;-&apos; if numerator*denominator&lt;0 else &apos;&apos; result = [sign+str(n),&apos;.&apos;] stack = [] while remainder not in stack: stack.append(remainder) n, remainder = divmod(remainder*10, abs(denominator)) result.append(str(n)) idx = stack.index(remainder) result.insert(idx+2,&apos;(&apos;) result.append(&apos;)&apos;) return &apos;&apos;.join(result).replace(&apos;(0)&apos;,&apos;&apos;).rstrip(&apos;.&apos;) 165.Compare Version Numbers12345678910versions1 = [int(v) for v in version1.split(&apos;.&apos;)] versions2 = [int(v) for v in version2.split(&apos;.&apos;)] for i in range(max(len(versions1),len(versions2))): v1 = versions1[i] if i&lt;len(versions1) else 0 v2 = versions2[i] if i&lt;len(versions2) else 0 if v1&gt;v2: return 1 elif v1&lt;v2: return -1 return 0 103.Binary Tree Zigzag Level Order Traversal12345level,res,step = [root],[],0 while any(level): res.append([i.val for i in level] if not step%2 else [i.val for i in level[::-1]]) level,step=[child for i in level for child in [i.left,i.right] if child], step+1 return res 61.Rotate List1234567891011121314if not head: return None p=q=head l=1 while p.next: p = p.next l += 1 p.next=head k%=l for _ in range(abs(l-k-1)): q=q.next ans = q.next q.next = None return ans 131.Palindrome Partitioning123456789101112def dfs(s,path,res): if not s: res.append(path[:]) return for i in range(1,len(s)+1): if s[:i] == s[i-1::-1]: path.append(s[:i]) dfs(s[i:],path,res) path.pop() res = [] dfs(s,[],res) return res 43.Multiply Strings12345678910res = [0]*(len(num1)+len(num2)) for i,v1 in enumerate(reversed(num1)): for j,v2 in enumerate(reversed(num2)): int1 = ord(v1)-ord(&apos;0&apos;) int2 = ord(v2)-ord(&apos;0&apos;) res[i+j] += int1*int2 res[i+j+1]+=res[i+j]//10 res[i+j] %=10 while len(res) &gt; 1 and res[-1]==0: res.pop() return &apos;&apos;.join(str(v) for v in res)[::-1] 150.Evaluate Reverse Polish Notation12345678910111213141516171819stack = [] for t in tokens: if t not in [&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;]: stack.append(int(t)) else: r,l=stack.pop(),stack.pop() if t == &quot;+&quot;: stack.append(l+r) elif t == &quot;-&quot;: stack.append(l-r) elif t == &quot;*&quot;: stack.append(l*r) else: if l*r &lt; 0 and l%r !=0: stack.append(l/r+1) else: stack.append(l/r) return stack.pop() 680.Valid Palindrome II1234567left,right=0,len(s)-1 while left&lt;right: if s[left] != s[right]: one,two=s[left:right],s[left + 1:right + 1] return one == one[::-1] or two == two[::-1] left,right = left+1, right-1 return True 713.Subarray Product Less Than K12345678910111213if k&lt;=1: return 0 n,count=len(nums),0 left,pro=0,1 for right, n in enumerate(nums): pro *= n while pro &gt;= k: pro //= nums[left] left+=1 count += right - left +1 return count 322.Coin Change12345MAX = float(&apos;inf&apos;) dp=[0]+[MAX]*amount for i in xrange(1,amount+1): dp[i]=min(dp[i-c] if i-c&gt;=0 else MAX for c in coins) + 1 return [dp[-1],-1][dp[-1]==MAX] 119.Pascalâ€™s Triangle II1234row = [1] for _ in range(rowIndex): row = [x+y for x,y in zip([0]+row,row+[0])] return row 1021.Remove Outermost Parentheses123456789for i in range(len(S)): if S[i] == &apos;(&apos;: r += 1 if S[i] == &apos;)&apos;: l += 1 if l == r: res.append(S[j+1:i]) j = i+1 return &apos;&apos;.join(res) 518.Coin Change 2123456def change(self, amount, coins): dp = [1] + [0]*amount for i in coins: for j in range(i,amount+1): dp[j] += dp[j-i] return dp[-1] 56.Merge Intervals123456789res = [] for s in sorted(S,key=lambda i: i.start): if len(res) != 0 and res[-1].start &lt;= s.start &lt;= res[-1].end: node = res.pop() res.append(Interval(node.start,max(node.end,s.end))) else: res.append(s) return res 31.Next Permutation12345678910i = len(nums)-1 while i &gt; 0: if nums[i] &gt; nums[i-1]: for j in xrange(len(nums)-1,0,-1): if nums[j]&gt;nums[i-1]: nums[j],nums[i-1]=nums[i-1],nums[j] break break i -= 1 nums[i:] = nums[i:][::-1] 856.Score of Parentheses12345678stack = [0] for s in S: if s == &quot;(&quot;: stack.append(0) else: last = stack.pop() stack[-1] += last*2 or 1 return stack.pop() 941.Valid Mountain Array1234i,j,n = 0,len(A)-1,len(A) while i+1 &lt; n and A[i] &lt; A[i+1]: i+=1 while j &gt; 0 and A[j-1]&gt;A[j]: j-=1 return 0&lt;i==j&lt;n-1 55.Jump Game123456m = 0 for i,n in enumerate(nums): if i &gt; m: return False m = max(m,i+n) return True 90.Subsets II123456789101112def subsetsWithDup(self, nums): nums.sort() res = [] self.dfs(nums, 0, [], res) return res def dfs(self,nums,index,path,res): res.append(path) for i in xrange(index,len(nums)): if i &gt; index and nums[i] == nums[i-1]: continue self.dfs(nums,i+1,path+[nums[i]],res) 390.Elimination Game1234arr = range(1,n+1) while len(arr) &gt; 1: arr = arr[1::2][::-1] return arr[0]]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåå…­ï¼‰]]></title>
    <url>%2F2019%2F03%2F31%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[è®¤çœŸå­¦ä¹ å•¦leetcodeåˆ·é¢˜è®°å½•(åå…­)646.Maximum Length of Pair Chain12345cur, res = float(&apos;-inf&apos;), 0 for p in sorted(pairs, key = lambda x:x[1]) : if cur &lt; p[0] : cur, res = p[1], res+1 return res 406.Queue Reconstruction by Heightinput: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]subarray after step 1: [[7,0], [7,1]]subarray after step 2: [[7,0],[6,1], [7,1]]12345678910111213141516d = &#123;&#125; for h,k in people: if h not in d: d[h] = [[h,k]] else: d[h].append([h,k]) res =[] for h in sorted(d.keys(), reverse = True): group = sorted(d[h]) if not res: res += group else: for h,k in group: res.insert(k,[h,k]) return res 101.Symmetric Tree123456789101112if not root: return True stack = [(root.left,root.right)] while stack: cur = stack.pop() l,r = cur[0],cur[1] if not l and not r: continue if not l and r or not r and l or l.val != r.val: return False stack.append((l.left,r.right)) stack.append((l.right,r.left)) return True 213.House Robber II1234567def robs(nums): a,b = 0,0 for i in nums: a,b = b, max(a+i,b) return b return max(robs(nums[len(nums)!=1:]),robs(nums[:-1])) 337.House Robber IIIf2(node) = f1(node.left) + f1(node.right)andf1(node) = max( f2(node.left)+f2(node.right)+node.value, f2(node) )123456789def rob(self, root): return self.robs(root)[1] def robs(self, node): if node is None: return (0,0) l = self.robs(node.left) r = self.robs(node.right) return (l[1]+r[1], max(l[1]+r[1],l[0]+r[0]+node.val)) 102.Binary Tree Level Order Traversal12345ans,level = [],[root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 653.Two Sum IV - Input is a BST123456789if not root: return False bfs,s=[root],set() for i in bfs: if k-i.val in s: return True s.add(i.val) if i.left: bfs.append(i.left) if i.right: bfs.append(i.right) return False 494.Target Sum123456789if not nums: return 0 dic = &#123;nums[0]:1,-nums[0]:1&#125; if nums[0] != 0 else &#123;0:2&#125; for i in range(1,len(nums)): tdic = &#123;&#125; for d in dic: tdic[d+nums[i]] = tdic.get(d+nums[i],0) + dic.get(d,0) tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0) dic = tdic return dic.get(S,0) 309.Best Time to Buy and Sell Stock with Cooldown123456789if len(prices)&lt;2: return 0 sell,buy,prev_sell,prev_buy=0,-prices[0],0,0 for price in prices: prev_buy=buy buy=max(prev_sell-price,prev_buy) prev_sell=sell sell=max(prev_buy+price,prev_sell) return sell 11.Container With Most Water123456789i,j = 0, len(height)-1 water = 0 while i&lt;j: water = max(water,(j-i)*min(height[i],height[j])) if height[i] &lt; height[j]: i+=1 else: j-=1 return water 75.Sort Colors123456789101112p1,p2=0,len(nums)-1 p=0 while p&lt;=p2: if nums[p]&lt;1: nums[p],nums[p1]=nums[p1],nums[p] p1+=1 p+=1 elif nums[p]&gt;1: nums[p],nums[p2]=nums[p2],nums[p] p2-=1 else: p+=1 221.Maximal Square1234567891011if not matrix: return 0 m,n = len(matrix), len(matrix[0]) dp = [[0 if matrix[i][j] == &apos;0&apos; else 1 for j in range(0,n)] for i in range(0,m)] for i in range(1,m): for j in range(1,n): if matrix[i][j]==&apos;1&apos;: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else: dp[i][j] = 0 res = max(max(row) for row in dp) return res**2 560.Subarray Sum Equals K1234567dic = &#123;0:1&#125; res = presum = 0 for num in nums: presum += num res += dic.get(presum - k,0) dic[presum] = dic.get(presum,0) + 1 return res 78.Subsets1234res = [[]]for num in sorted(nums): res+=[item+[num] for item in res]return res 98.Validate Binary Search Tree123456def isValidBST(self, root,floor=float(&apos;-inf&apos;), ceiling=float(&apos;inf&apos;)): if not root: return True if root.val &lt;= floor or root.val &gt;= ceiling: return False return self.isValidBST(root.left, floor, root.val) and self.isValidBST(root.right, root.val, ceiling)]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåäº”ï¼‰]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[æ²‰è¿·åŠ¨æ€è§„åˆ’leetcodeåˆ·é¢˜è®°å½•(åäº”)24.Swap Nodes in Pairspre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next12345678dummy = pre = ListNode(0) pre.next = head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, a.next, b.next = b, b.next,a pre = a return dummy.next 414.Third Maximum Number123456789m1 = m2 = m3 = -float(&quot;inf&quot;) for num in nums: if num &gt; m1: m1,m2,m3 = num, m1,m2 elif m2&lt;num&lt;m1: m2,m3 = num,m2 elif m3&lt;num&lt;m2: m3 = num return m3 if m3&gt; -float(&quot;inf&quot;) else m1 å¦ä¸€ä¸ªæ–¹æ³•ï¼š1return sorted(set(nums))[-3] if len(set(nums))&gt;2 else max(nums) 515.Find Largest Value in Each Tree Row1234567891011121314ans = [] if not root: return ans queue = [root] while queue: ans.append(max(x.val for x in queue)) new = [] for node in queue: if node.left: new.append(node.left) if node.right: new.append(node.right) queue = new return ans 167.Two Sum II - Input array is sorted123456789l,r = 0, len(numbers) - 1 while l&lt;r: s = numbers[l] + numbers[r] if s == target: return [l+1,r+1] elif s &lt; target: l += 1 else: r -= 1 41.First Missing Positivehashtable12345678910for i in xrange(len(nums)): if nums[i] &gt; len(nums) or nums[i] &lt;= 0: nums[i] = len(nums) + 1 for i in xrange(len(nums)): if abs(nums[i])-1 &lt; len(nums): nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]) for i in xrange(len(nums)): if nums[i] &gt; 0: return i+1 return len(nums) + 1 129.Sum Root to Leaf Numbers123456789101112if not root: return 0 stack = [(root, str(root.val))] res = 0 while stack: root,s = stack.pop() if not root.left and root.right: res += int(s) if root.left: stack.append((root.left,s+str(root.left.val))) if root.right: stack.append((root.right,s+str(root.right.val))) return res 139.Word Break12345678dp = [False]*(len(s)+1) dp[0] = True for i in range(len(s)): if dp[i]: for j in range(i,len(s)): if s[i:j+1] in wordDict: dp[j+1] = True return dp[-1] 993.Cousins in Binary Tree123456789def dfs(node,parent,dp,mod): if node: if node.val == mod: return dp,parent return dfs(node.left,node,dp+1,mod) or dfs(node.right,node,dp+1,mod) dx,px = dfs(root,None,0,x) dy,py = dfs(root,None,0,y) return dx==dy and px!=py 91.Decode Wayså¯¹æ¯ä¸ªæ•°ç»„é¦–å…ˆåˆ¤æ–­å…¶æ˜¯å¦ä¸º0ï¼Œè‹¥æ˜¯å°†æ”¹ä¸ºdpèµ‹0ï¼Œè‹¥ä¸æ˜¯ï¼Œèµ‹ä¸Šä¸€ä¸ªdpå€¼ï¼Œæ­¤æ—¶ç›¸å½“å¦‚åŠ ä¸Šäº†dp[i - 1], ç„¶åŽçœ‹æ•°ç»„å‰ä¸€ä½æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æžœå­˜åœ¨ä¸”æ»¡è¶³å‰ä¸€ä½ä¸æ˜¯0ï¼Œä¸”å’Œå½“å‰ä¸ºä¸€èµ·ç»„æˆçš„ä¸¤ä½æ•°ä¸å¤§äºŽ26ï¼Œåˆ™å½“å‰dpå€¼åŠ ä¸Šdp[i - 2]123456789dp = [0 for i in range(3)] dp[0] = 1 for i,n in enumerate(s,1): dp[i%3] = 0 if s[i-1] != &quot;0&quot;: dp[i%3] += dp[(i-1)%3] if i&gt;1 and int(s[i-2:i]) &lt;=26 and int(s[i-2:i])&gt;=10: dp[i%3] += dp[(i-2)%3] return dp[len(s)%3] 413.Arithmetic Slicesdp again12345678cur,s = 0,0 for i in range(2,len(A)): if A[i] - A[i-1] == A[i-1] -A[i-2]: cur+=1 s += cur else: cur = 0 return s 714.Best Time to Buy and Sell Stock with Transaction Fee1234567891011buy = prices[0] res = 0 for p in prices: if buy &gt; p: buy = p else: tmp = p-buy-fee if tmp &gt; 0: res+=tmp buy = p - fee return res 338.Counting Bitsdp againï¼Œå¯ä»¥æ‰¾åˆ°è§„å¾‹ 1 [1], 2[10] 3[11], 4[100] 5[101] 6[110] 7[111]ï¼Œæ‰€ä»¥åœ¨çŽ°æœ‰çš„resä¸Š+1ï¼Œæœ€åŽå–0ï½žnumçš„reså°±å¯ä»¥äº†ã€‚1234res = [0,1] while len(res) &lt; num+1: res += [x+1 for x in res] return res[:num+1]]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåå››ï¼‰]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[å¸Œæœ›æ‹¿åˆ°offerï¼leetcodeåˆ·é¢˜è®°å½•(åå››)435.Non-overlapping Intervals1234567891011if not intervals: return 0 intervals.sort(key = lambda x: x.start) intervals = iter(intervals) curEnd,cnt = next(intervals).end,0 for x in intervals: if x.start &lt; curEnd: cnt+=1 curEnd = min(curEnd,x.end) else: curEnd = x.end return cnt 443.String Compressionä¸¤ä¸ªæŒ‡é’ˆ1234567891011left = i = 0 while i&lt;len(chars): char,length = chars[i],1 while (i+1) &lt; len(chars) and char == chars[i+1]: length, i = length+1, i+1 chars[left] = char if length &gt; 1: len_str = str(length) chars[left+1:left+1+len(len_str)] = len_str left += len(len_str) left,i = left+1,i+1 662.Maximum Width of Binary Tree123456789101112res = 0 level = [(root,0)] while level: new_level = [] res = max(res,level[-1][1]-level[0][1]+1) for node,pos in level: if node.left: new_level.append((node.left,pos*2)) if node.right: new_level.append((node.right,pos*2+1)) level = new_level return res 455.Assign Cookies12345i,j,g,s = 0,0,sorted(g),sorted(s) while i &lt; len(g) and j &lt; len(s): i+=g[i] &lt;= s[j] j+=1 return i 228.Summary Ranges12345678910111213141516def printR(self,l,r): if l == r: return str(l) else: return str(l) +&quot;-&gt;&quot;+str(r) if not nums: return [] res,i,start = [],0,0 while i&lt;len(nums)-1: if nums[i] + 1 != nums[i+1]: res.append(self.printR([start],nums[i])) start = i+1 i += 1 res.append(self.printR(nums[start],nums[i])) return res 153.Find Minimum in Rotated Sorted Array123456789i=0 j=len(nums)-1 while i&lt;j: m=i+(j-i)/2 if nums[m]&gt;nums[j]: i=m+1 else: j=m return nums[i] 606.Construct String from Binary Tree12345678910if not t: return &apos;&apos; result = str(t.val) if t.left: result += &apos;(&apos;+self.tree2str(t.left) + &apos;)&apos; if t.right: result += &apos;(&apos;+self.tree2str(t.right) + &apos;)&apos; elif t.right: result += &apos;()&apos;+ &apos;(&apos;+self.tree2str(t.right) + &apos;)&apos; return result 611.Valid Triangle Number123456789101112ans = 0 nums.sort() for i in range(2,len(nums)): s =0 e = i - 1 while s &lt; e: if nums[s] + nums[e] &gt; nums[i]: ans+= e-s e -= 1 else: s += 1 return ans 74.Search a 2D Matrix123456789101112131415if not matrix or target is None: return False row,cols = len(matrix),len(matrix[0]) low,high = 0,row*cols - 1 while low&lt;=high: mid = (low+high)/2 num = matrix[mid/cols][mid%cols] if num == target: return True elif num&lt;target: low = mid+1 else: high = mid-1 return False 49.Group Anagrams12345678hashmap = &#123;&#125; for st in strs: key = &apos;&apos;.join(sorted(st)) if key not in hashmap: hashmap[key] = [st] else: hashmap[key] += [st] return hashmap.values() 219.Contains Duplicate IIä¹‹å‰å†™è¿‡1ï¼Œè¿˜æ˜¯æ¯”è¾ƒç®€å•çš„123456dic = &#123;&#125;for i,v in enumerate(nums): if v in dic and i - dic[v] &lt;= k: return True dic[v] = ireturn False 227.Basic Calculator II12345678910111213141516171819202122if not s: return &quot;0&quot; stack,num,sign = [],0,&quot;+&quot; for i in xrange(len(s)): if s[i].isdigit(): num = num*10 + ord(s[i]) - ord(&quot;0&quot;) if(not s[i].isdigit() and not s[i].isspace()) or i == len(s) - 1: if sign == &quot;-&quot;: stack.append(-num) elif sign == &quot;+&quot;: stack.append(num) elif sign == &quot;*&quot;: stack.append(stack.pop()*num) else: tmp = stack.pop() if tmp//num &lt; 0 and tmp%num != 0: stack.append(tmp//num+1) else: stack.append(tmp//num) sign = s[i] num = 0 return sum(stack) 921.Minimum Add to Make Parentheses Valid12345678910i,j = 0,0 for s in S: if s == &quot;(&quot;: j += 1 else: j -= 1 if j&lt;0: i += 1 j += 1 return i + j 229.Majority Element IIæ‘©å°”æŠ•ç¥¨æ³•ï¼šè¯¥ç®—æ³•åœ¨å…¶å±€éƒ¨å˜é‡ä¸­ç»´æŠ¤ä¸€ä¸ªåºåˆ—å…ƒç´ å’Œä¸€ä¸ª è®¡æ•°å™¨ ï¼Œè®¡æ•°å™¨æœ€åˆä¸ºé›¶ã€‚ç„¶åŽï¼Œå®ƒä¸€æ¬¡ä¸€ä¸ªåœ°å¤„ç†åºåˆ—çš„å…ƒç´ ã€‚å¤„ç†å…ƒç´ xæ—¶ï¼Œå¦‚æžœè®¡æ•°å™¨ä¸ºé›¶ï¼Œåˆ™ç®—æ³•å°†xå­˜å‚¨ä¸ºå…¶ç»´æŠ¤çš„åºåˆ—å…ƒç´ ï¼Œå¹¶å°†è®¡æ•°å™¨è®¾ç½®ä¸º1ã€‚å¦åˆ™ï¼Œå®ƒå°†xä¸Žå­˜å‚¨çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶ä½¿è®¡æ•°å™¨é€’å¢žï¼ˆå¦‚æžœç›¸ç­‰ï¼‰æˆ–é€’å‡è®¡æ•°å™¨ã€‚è¿™é“é¢˜é€‰å‡ºä¸¤ä¸ªå€™é€‰äººå°±è¡Œäº†ã€‚1234567891011121314151617181920212223242526if not nums: return [] can1 = 0 can2 = 1 c1 = c2 = 0 for num in nums: if num == can1: c1+=1 elif num == can2: c2+=1 elif c1 == 0: can1, c1 = num,1 elif c2 == 0: can2, c2 = num, 1 else: c1,c2 = c1-1,c2-1 c1,c2 = 0,0 for num in nums: if num == can1: c1+=1 elif num==can2: c2+=1 res, l = [], len(nums) if (c1 &gt; l/3): res.append(can1) if (c2 &gt; l/3): res.append(can2) return res 145.Binary Tree Postorder Traversal12345678res, stack = [],[root] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1]]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåä¸‰ï¼‰]]></title>
    <url>%2F2019%2F03%2F06%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[leetcodeåˆ·é¢˜è®°å½•(åä¸‰)æ¯•è®¾å’‹åŠžå•Š 141.Linked List Cycle123456789101112131415def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head == None: return False m1 = head m2 = head.next while m2 != None and m2.next != None: m1 = m1.next m2 = m2.next.next if m2 is m1: return True return False 137.Single Number II12345one, two = 0, 0 for x in nums: one, two, three = one ^ x, two | (one &amp; x), two &amp; x one, two = one &amp; ~three, two &amp; ~three return one 674.Longest Continuous Increasing Subsequence12345678910111213if not nums: return 0 l = len(nums) if l &lt;=1 : return 1 res = 1 max1 = 1 for i in range(1,l): if i and nums[i-1] &lt; nums[i]: res +=1 if res &gt; max1: max1 = res else: res = 1 return max1 961.N-Repeated Element in Size 2N Array123456a = [] for i in A: if i not in a: a += [i] else: return i 448.Find All Numbers Disappeared in an Arrayæ ‡è®°å‡ºçŽ°äº†çš„æ•°å­—ä¸ºè´Ÿæ•°1234for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = -abs(nums[index]) return [index for index,n in enumerate(nums,start=1) if n &gt; 0] 257.Binary Tree Paths123456789def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] if not root.left and not root.right: return [str(root.val)] return [str(root.val)+&apos;-&gt;&apos;+i for i in self.binaryTreePaths(root.left)] + [str(root.val) + &apos;-&gt;&apos; + i for i in self.binaryTreePaths(root.right)] 160.Intersection of Two Linked Lists123456789101112131415161718curA, curB = headA, headB lenA,lenB = 0,0 while curA: lenA += 1 curA = curA.next while curB: lenB += 1 curB = curB.next curA, curB = headA, headB if lenA &gt;= lenB: for i in range(abs(lenA-lenB)): curA = curA.next else: for i in range(abs(lenA-lenB)): curB = curB.next while curB != curA: curA,curB = curA.next,curB.next return curA 162.Find Peak Element123456789101112l = 0 r = len(nums) - 1 while l &lt; r: mid = (r+l)/2 if nums[mid]&gt;nums[mid+1] and nums[mid] &gt; nums[mid-1]: return mid if nums[mid] &lt; nums[mid + 1]: l = mid + 1 else: r = mid - 1 return l 83.Remove Duplicates from Sorted List12345678910111213if head == None: return head cur = head.next pre = head while cur != None: if cur.val == pre.val: pre.next = cur.next cur = cur.next else: cur = cur.next pre = pre.next return head 539.Minimum Time Difference1234567def minutes(p): h,m = map(int,p.split(&apos;:&apos;)) return 60*h+m mins = sorted(map(minutes,timePoints)) mins.append(60*24 + mins[0]) return min(b-a for a,b in zip(mins,mins[1:])) 506.Relative Ranks123sort = sorted(nums)[::-1] rank = [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;]+map(str,range(4,len(nums)+1)) return map(dict(zip(sort,rank)).get,nums) 402.Remove K Digits12345678def shrink(num): a = len(num) for i in range(a - 1): if num[i] &gt; num[i+1]: return num[:i]+num[i+1:]for i in range(k): num = shrink(num)return str(int(num)) if num else &quot;0&quot; 404.Sum of Left Leaves123456789self.sum = 0 def dfs(root): if root: if root.left and not root.left.left and not root.left.right: self.sum += root.left.val dfs(root.left) dfs(root.right) dfs(root) return self.sum]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåäºŒï¼‰]]></title>
    <url>%2F2019%2F03%2F03%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[leetcodeåˆ·é¢˜è®°å½•(åäºŒ)èœ 33.Search in Rotated Sorted Arrayç”¨äºŒåˆ†æŸ¥æ‰¾1234567891011121314151617181920212223242526def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return -1 low, high = 0, len(nums)-1 while low &lt;= high: mid = (low+high)&gt;&gt;1 if target== nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 35.Search Insert Positionå› ä¸ºæ˜¯sortedæ‰€ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾123456789101112131415161718class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; low = 0 high = len(nums) - 1 while low&lt;=high: mid = (low+high)//2 if nums[mid] == target: return mid if nums[mid] &gt; target: high = mid - 1 if nums[mid] &lt; target: low = mid + 1 return ((high+low)//2 + 1) å…¶å®žåˆšå¼€å§‹æƒ³åˆ°çš„æ˜¯ä¸€ä¸ªå¾ˆæ…¢çš„æ–¹æ³•-&gt;123nums.append(target)nums.sort()return nums.index(target) 39.Combination Sumdfs123456789101112res = [] def dfs(target, index, path): if target &lt; 0: return if target == 0: res.append(path) return for i in range(index,len(candidates)): dfs(target-candidates[i],i,path+[candidates[i]]) dfs(target,0,[]) return res 53.Maximum Subarray123456cur = maxs = -float(&apos;inf&apos;) for i in xrange(len(nums)): cur +=nums[i] cur = max(cur,nums[i]) maxs = max(maxs,cur) return maxs 538.Convert BST to Greater Tree12345678910111213a = 0 def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return None self.convertBST(root.right) self.a += root.val root.val = self.a self.convertBST(root.left) return root 860.Lemonade Change12345678910111213141516five, ten = 0, 0 for i in bills: if i == 5: five+=1 elif i == 10: five -=1 ten +=1 else: if ten &gt; 0: five -=1 ten -=1 else: five -=3 if five &lt; 0: return False return True 100.Same Tree123456if p == None and q == None: return True if p and q: return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) else: return False 594.Longest Harmonious Subsequence12345678910111213141516def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in nums: if i not in m: m[i] = 1 else: m[i] += 1 l = 0 for i in m: if m.get(i+1): l = max(l,m[i]+m[i+1]) return l 671.Second Minimum Node In a Binary Tree1234567891011121314151617def findSecondMinimumValue(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = float(&apos;inf&apos;) minx = root.val def dfs(node): if node: if minx&lt;node.val&lt;self.ans: self.ans = node.val elif node.val == minx: dfs(node.left) dfs(node.right) dfs(root) return self.ans if self.ans &lt; float(&apos;inf&apos;) else -1 152.Maximum Product Subarrayæ™®é€šæ–¹æ³•1234567max1 = big = small = nums[0] for i in nums[1:]: temp = big big = max(i,i*big,i*small) small = min(i,i*temp,i*small) max1 = max(max1,big) return max1 åœ¨è®¨è®ºé‡Œçœ‹åˆ°çš„å¥‡å¦™æ–¹æ³•123456def maxProduct(self, A): B = A[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B) 942.DI String Match123456789101112131415161718def diStringMatch(self, S): &quot;&quot;&quot; :type S: str :rtype: List[int] &quot;&quot;&quot; i = 0 j = len(S) res = [] for x in S: if x==&apos;I&apos;: res.append(i) i+=1 else: res.append(j) j-=1 res.append(j if S[-1]==&apos;D&apos; else i) return res]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆåï¼‰]]></title>
    <url>%2F2018%2F08%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•(å)å¼€å§‹æŒ‰é¡ºåºåˆ·äº†ï¼ˆhardè¿˜æ˜¯éšç¼˜å§ï¼‰ï½žè¯­è¨€ç­ä¹Ÿå¼€è¯¾äº†ï¼Œäº‹æƒ…å¤šäº†èµ·æ¥äº†ï¼Œå¸Œæœ›æœ‰ä¸€ä¸ªæ°¸æ— æ­¢å¢ƒçš„å…«æœˆ 1. Two Sumåœ¨pythonä¸­ï¼Œå¯»æ‰¾å…ƒç´ åœ¨dictionaryä¸­çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(1),åœ¨listä¸­ä¸ºO(n)123456789n = len(nums) if n&lt;=1: return False dic = &#123;&#125; for i in range(n): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 2. Add Two Numbers12345678910ret = cur = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val/10 cur.next = ListNode(val%10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next 3. Longest Substring Without Repeating Charactersæ‰¾æœ€é•¿ä¸é‡å¤å­ä¸²ï¼Œè§‰å¾—è¿™ä¸ªæ€æƒ³ä»¥åŽè¿˜ä¼šç”¨åˆ°123456789start = maxL = 0 usedCh = &#123;&#125; for i in range(len(s)): if s[i] in usedCh and start &lt;= usedCh[s[i]]: start = usedCh[s[i]] + 1 else: maxL = max(maxL,i-start+1) usedCh[s[i]] = i return maxL 5. Longest Palindromic Substringæ‰¾æœ€é•¿å›žæ–‡å­ä¸²ï¼Œä¼¼ä¹Žåšè¿‡ç¬¬ä¸€ç§åŠžæ³•ç›´æŽ¥è§£ï¼Œæš´åŠ›ðŸ¸123456789101112131415161718192021class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = &quot;&quot; for i in xrange(len(s)): tmp = self.helper(s,i,i) if len(tmp) &gt;len(res): res = tmp tmp = self.helper(s,i,i+1) if len(tmp) &gt;len(res): res = tmp return res def helper(self,s,l,r): while l&gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1 r+=1 return s[l+1:r] ç¬¬äºŒç§å­¦ä¹ ä¸€ä¸‹Manacherç®—æ³•ï¼šåœ¨å­—ç¬¦ä¸²é¦–å°¾ä»¥åŠå„ä¸ªå­—ç¬¦é—´æ’å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œå®šä¹‰è¾…åŠ©æ•°ç»„p[]è¡¨ç¤ºä»¥iä¸ºä¸­å¿ƒçš„æœ€é•¿å›žæ–‡çš„åŠå¾„ï¼Œåˆ™p[i]-1å°±æ˜¯åŽŸå­—ç¬¦ä¸²ä¸­æœ€é•¿å›žæ–‡çš„é•¿åº¦ã€‚p[]çš„æ±‚è§£ï¼šè®¾ç½®ä¸¤ä¸ªå˜é‡ï¼Œmx å’Œ id ã€‚mx ä»£è¡¨ä»¥ id ä¸ºä¸­å¿ƒçš„æœ€é•¿å›žæ–‡çš„å³è¾¹ç•Œï¼Œä¹Ÿå°±æ˜¯mx = id + p[id]ã€‚åˆ™p[i] = min(p[2 * id - i], mx - i)12345678910111213141516def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; T = &apos;#&apos;.join(&apos;^&#123;&#125;$&apos;.format(s)) n = len(T) p = [0]*n c = r= 0 for i in range(1,n-1): while T[i+1+p[i]] == T[i-1-p[i]]: p[i]+=1 if i + p[i] &gt;r: c,r=i,i+p[i] maxLen, centerIndex = max((n, i) for i, n in enumerate(p)) return s[(centerIndex - maxLen)//2: (centerIndex + maxLen)//2] 6. ZigZag Conversion12345678910111213if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index,step = 0,1 for x in s: L[index] += x if index == 0: step =1 elif index == numRows - 1: step = -1 index +=step return &apos;&apos;.join(L) 7. Reverse Integerè¦è€ƒè™‘åˆ°è¾¹ç•Œæƒ…å†µ123s = (x&gt;0) - (x&lt;0) r = int(str(x*s)[::-1]) return s*r*(r&lt;2**31) ä¸ç”¨strçš„æ–¹æ³•1234567891011i,res,sign = 0,0,1 if x&lt;0: sign = -1 x = abs(x) while x!=0: res=res*10+(x%10) x/=10 if res&lt;-2147483648 or res&gt;2147483648: return 0 else: return res*sign 9.Palindrome Numberåˆ¤æ–­æ•°å­—æ˜¯å¦æ˜¯å›žæ–‡1234567if x&lt;0: return False p,res = x,0 while p: res = res*10 +p%10 p /= 10 return res == x 14. Longest Common Prefix1234567891011121314s = len(strs) if s == 0: return &apos;&apos; lens = [len(str) for str in strs] min_len = min(lens) result = &apos;&apos; for i in range(1,min_len+1): pre = strs[0][:i] for s in strs: if s[:i] != pre: return result result = pre return result çœŸçš„å¥½å¿™å•Šâ€¦â€¦]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¹ï¼‰]]></title>
    <url>%2F2018%2F07%2F18%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•(ä¹)åœ¨å¤©å›½çš„åŠ¨æ€è§„åˆ’ Fizz Buzz1return [str(i)*(i%5!=0 and i%3!=0) + &apos;Fizz&apos;*(i%3 == 0) + &apos;Buzz&apos;*(i%5 ==0) for i in range(1,n+1)] Single Number123456dic =&#123;&#125;for num in nums: dic[num] = dic.get(num,0) +1for key, value in dic.items(): if value == 1: return key å¦å¤–è¿˜æœ‰ä¸€ç§æ—¶é—´å¤æ‚åº¦ä¸ºo(n)çš„æ–¹æ³•ï¼š1return reduce(lambda x,y:x^y, nums) reduce()å‡½æ•°å°†ä¸€ä¸ªæ•°æ®é›†åˆï¼ˆé“¾è¡¨ï¼Œå…ƒç»„ç­‰ï¼‰ä¸­çš„æ‰€æœ‰æ•°æ®è¿›è¡Œä¸‹åˆ—æ“ä½œï¼šç”¨ä¼ ç»™ reduce ä¸­çš„å‡½æ•° functionï¼ˆæœ‰ä¸¤ä¸ªå‚æ•°ï¼‰å…ˆå¯¹é›†åˆä¸­çš„ç¬¬ 1ã€2 ä¸ªå…ƒç´ è¿›è¡Œæ“ä½œï¼Œå¾—åˆ°çš„ç»“æžœå†ä¸Žç¬¬ä¸‰ä¸ªæ•°æ®ç”¨ function å‡½æ•°è¿ç®—ï¼Œæœ€åŽå¾—åˆ°ä¸€ä¸ªç»“æžœ Product of Array Except Self1234567891011output=[] p = 1 n = len(nums) for i in range(0,n): output.append(p) p = p*nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i]*p p = p*nums[i] return output Sum of Two Integers123456MAX = 0x7FFFFFFF MIN = 0x80000000 mask = 0xFFFFFFFF while b!=0: a,b = (a^b)&amp;mask,((a&amp;b)&lt;&lt;1)&amp;mask return a if a&lt;=MAX else ~(a^mask) Top K Frequent Elementsé¡ºä¾¿å­¦ä¹ heapqæ¨¡å—çš„ä½¿ç”¨ã€‚ item = heapreplace(heap,item) å¼¹å‡ºå¹¶è¿”å›žæœ€å°å€¼ nlargest(n , iterbale, key=None) ä»Žå †ä¸­æ‰¾å‡ºåšå¤§çš„Nä¸ªæ•°ï¼Œkeyçš„ä½œç”¨å’Œsorted( )æ–¹æ³•é‡Œé¢çš„keyç±»ä¼¼ï¼Œç”¨åˆ—è¡¨å…ƒç´ çš„æŸä¸ªå±žæ€§å’Œå‡½æ•°ä½œä¸ºå…³é”®å­—ã€‚ nsmallest(n, iterable, key=None) æ‰¾åˆ°å †ä¸­æœ€å°çš„Nä¸ªæ•°ã€‚ heappushpop() å°†å€¼æ’å…¥åˆ°å †ä¸­åŒæ—¶å¼¹å‡ºå †ä¸­çš„æœ€å°å€¼ã€‚ merge(*iterables) åˆå¹¶å¤šä¸ªå †ç„¶åŽè¾“å‡º12345from collections import Counter import heapq - [ ] c = Counter(nums) return heapq.nlargest(k,c,c.get) Excel Sheet Column Number12345n=len(s) num=0 for i,x in enumerate(s): num+=(ord(x)-64)*26**(n-i-1) return num è¿˜å¯ä»¥ç”¨reduceåš=ã€‚= Majority Element12345678910 return sorted(nums)[len(nums)//2]//å¦ä¸€ç§åŠžæ³•pool = [] n = len(nums) for i in range(n): if nums[i] not in pool: if nums.count(nums[i]) &gt; n/2: return nums[i] pool.append(nums[i]) Binary Tree Inorder Traversalé€’å½’æŒºç®€å•çš„ï¼Œæ‰€ä»¥åªåšäº†è¿­ä»£1234567891011stack=[] output=[] while True: while root: stack.append(root) root = root.left if not stack: return output node = stack.pop() output.append(node.val) root = node.right Best Time to Buy and Sell Stock1234567if not prices: return 0 max_profit = sell_price = 0 for price in prices[::-1]: sell_price = max(sell_price, price) max_profit = max(max_profit,sell_price - price) return max_profit Best Time to Buy and Sell Stock IIæƒŠäº†è¿™é“é¢˜æˆ‘è¿˜æƒ³äº†å¥½ä¹…ï¼ŒåŽŸæ¥è¿™ä¹ˆç®€å•orz1return sum(max(prices[i+1]-prices[i],0) for i in range(len(prices)-1)) Permutations1234567891011121314if not nums: return None stack = [[[nums[0]],0]] i,res = 0, [] while(stack): arr, index = stack.pop() if index == len(nums)-1: res.append(arr) else: for i in range(len(arr)+1): newPermutation = arr[:i]+[nums[index+1]]+arr[i:] stack.append([newPermutation,index+1]) return res First Unique Character in a String123letters=&apos;abcdefghijklmnopqrstuvwxyz&apos; index = [s.index(l) for l in letters if s.count(l) == 1] return min(index) if len(index) &gt; 0 else -1 Generate Parenthesesä¹Ÿæ˜¯å…¨æŽ’åˆ—é—®é¢˜1234567891011res = [] def dfs(l,r,path,res): if r &lt; l or l == -1 or r == -1: return if l == 0 and r == 0: res.append(path[:]) else: dfs(l-1, r, path + &quot;(&quot;, res) dfs(l, r-1, path + &quot;)&quot;, res) dfs(n,n,&quot;&quot;,res) return(res) Missing Number12n = len(nums) return n*(n+1)/2 - sum(nums)]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå…«ï¼‰]]></title>
    <url>%2F2018%2F05%2F30%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå…«ï¼‰349. Intersection of Two Arrays123456789 def intersection(self, nums1, nums2): â€œâ€â€ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] â€œâ€â€ n1 = set(nums1) n2 = set(nums2) return list(n1&amp;n2) Valid Anagram12345678910111213141516def isAnagram(self, s, t): â€œâ€â€ :type s: str :type t: str :rtype: bool â€œâ€â€ if len(s) != len(t): return False count = collections.defaultdict(int) for c in s: count[c] += 1 for c in t: count[c] -= 1 if count[c] &lt; 0: return False return True defaultdict å°±æ˜¯ä¸€ä¸ªå­—å…¸ï¼Œåªä¸è¿‡pythonè‡ªåŠ¨çš„ä¸ºå®ƒçš„é”®èµ‹äº†ä¸€ä¸ªåˆå§‹å€¼ã€‚è¿™ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ ä¸æ˜¾ç¤ºçš„ä¸ºå­—å…¸çš„é”®èµ‹åˆå€¼pythonä¸ä¼šæŠ¥é”™ 350. Intersection of Two Arrays II12345678def intersect(self, nums1, nums2): â€œâ€â€ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] â€œâ€â€ a,b = map(collections.Counter,(nums1,nums2)) return list((a&amp;b).elements()) 496. Next Greater Element I123456789101112def nextGreaterElement(self, findNums, nums): â€œâ€â€ :type findNums: List[int] :type nums: List[int] :rtype: List[int] â€œâ€â€ greater,stack = &#123;&#125;,[] for n in nums: while stack and n &gt; stack[-1]: greater[stack.pop()] = n stack.append(n) return [greater[n] if n in greater else -1 for n in findNums] 693. Binary Number with Alternating Bits12s = bin(n) return â€™00â€™ not in s and â€™11â€™ not in s 553. Optimal Division12345678910 def optimalDivision(self, nums): â€œâ€â€ :type nums: List[int] :rtype: str â€œâ€â€ nums = list(map(str, nums)) if len(nums) &gt; 2: nums[1] = â€œ(â€œ +nums[1] nums[-1] = nums[-1] + â€œ)â€ return â€œ/â€œ.join(nums) è¿™é‡Œæ˜¯æ¯”è¾ƒtrickyçš„ï¼Œæœ€å¤§çš„é™¤æ³•ä¸€å®šæ˜¯X1/(X2..Xn) 647. Palindromic Substrings1234567891011def countSubstrings(self, s): â€œâ€â€ :type s: str :rtype: int â€œâ€â€ res = 0 for j in range(len(s) + 1): for i in range(j): if s[i:j] == s[i:j][::-1]: res +=1 return res 226. Invert Binary Tree123456789101112def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack += node.left, node.right return root ```é€’å½’æ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæ‰€ä»¥åªå†™è¿­ä»£]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¥žç»ç½‘ç»œå­¦ä¹ note2]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0note2%2F</url>
    <content type="text"><![CDATA[ç¥žç»ç½‘ç»œå­¦ä¹ note2note1å’ŒåŠ¨æ€è§„åˆ’éƒ½è¢«æˆ‘åƒæŽ‰äº† ä¸€äº›åŸºç¡€çŸ¥è¯†å¯¹ä¸€èˆ¬çš„ç›‘ç£å¼å­¦ä¹ ï¼Œä½¿ç”¨æ ‡å‡†çš„ç¥žç»ç½‘ç»œæ¨¡åž‹å¯¹å›¾åƒè¯†åˆ«å¤„ç†é—®é¢˜ï¼Œä½¿ç”¨å·ç§¯ç¥žç»ç½‘ç»œï¼ˆCNNï¼‰å¯¹ç±»ä¼¼è¯­éŸ³çš„åºåˆ—ä¿¡å·ï¼Œä½¿ç”¨å¾ªçŽ¯ç¥žç»ç½‘ç»œï¼ˆRNNï¼‰ Structured Data: æœ‰å®žé™…æ„ä¹‰çš„æ•°æ®Unstructured Dataï¼šæ¯”è¾ƒæŠ½è±¡çš„æ•°æ® äºŒåˆ†ç±»é€»è¾‘å›žå½’ï¼ˆLogisitic Regressionï¼‰ä¸€èˆ¬ç”¨æ¥è§£å†³äºŒåˆ†ç±»ï¼ˆBinary Classificationï¼‰é—®é¢˜é€»è¾‘å›žå½’çš„é¢„æµ‹è¾“å‡ºå¯ä»¥å†™æˆï¼šsigmoidå‡½æ•°çš„æ„ä¹‰åœ¨äºŽå°†é€»è¾‘å›žå½’çš„è¾“å‡ºé™å®šåœ¨[0,1]é—´ æŸå¤±å‡½æ•°ï¼ˆcost functionï¼‰ï¼šé€‰æ‹©çš„æŸå¤±å‡½æ•°ä¸€èˆ¬åº”è¯¥æ˜¯convexçš„æ¢¯åº¦ä¸‹é™ï¼šä½¿ç”¨æ¢¯åº¦ä¸‹é™æ¥è®¡ç®—å‡ºåˆé€‚çš„wï¼Œbå€¼ï¼Œæœ€å°åŒ–æŸå¤±å‡½æ•° Pythonæœºåˆ¶å‘é‡åŒ–ï¼ˆVectorizationï¼‰ åœ¨pythonä¸­ä½¿ç”¨å‘é‡åŒ–è¦æ¯”ä½¿ç”¨å¾ªçŽ¯è®¡ç®—é€Ÿåº¦å¿«å¯¹äºŽæ‰€æœ‰mä¸ªæ ·æœ¬ï¼ŒdZã€dbã€dwå¯è¡¨ç¤ºä¸ºï¼šZ = np.dot(w.T,X) +bA = sigmoid(Z)dZ = A - Ydw = 1/mnp.dot(X,dZ.T)db = 1/mnp.sum(dZ) w = w - alphadwb = b - alphadb pythonä¸­çš„å¹¿æ’­æœºåˆ¶ï¼š è®©æ‰€æœ‰è¾“å…¥æ•°ç»„éƒ½å‘å…¶ä¸­shapeæœ€é•¿çš„æ•°ç»„çœ‹é½ï¼Œshapeä¸­ä¸è¶³çš„éƒ¨åˆ†éƒ½é€šè¿‡åœ¨å‰é¢åŠ 1è¡¥é½ è¾“å‡ºæ•°ç»„çš„shapeæ˜¯è¾“å…¥æ•°ç»„shapeçš„å„ä¸ªè½´ä¸Šçš„æœ€å¤§å€¼ å¦‚æžœè¾“å…¥æ•°ç»„çš„æŸä¸ªè½´å’Œè¾“å‡ºæ•°ç»„çš„å¯¹åº”è½´çš„é•¿åº¦ç›¸åŒæˆ–è€…å…¶é•¿åº¦ä¸º1æ—¶ï¼Œè¿™ä¸ªæ•°ç»„èƒ½å¤Ÿç”¨æ¥è®¡ç®—ï¼Œå¦åˆ™å‡ºé”™ å½“è¾“å…¥æ•°ç»„çš„æŸä¸ªè½´çš„é•¿åº¦ä¸º1æ—¶ï¼Œæ²¿ç€æ­¤è½´è¿ç®—æ—¶éƒ½ç”¨æ­¤è½´ä¸Šçš„ç¬¬ä¸€ç»„å€¼ ç¥žç»ç½‘ç»œçš„æ­£å‘ä¼ æ’­ï¼šè¾“å…¥å±‚åˆ°éšè—å±‚ï¼Œä¸€æ¬¡é€»è¾‘å›žå½’è¿ç®—éšè—å±‚åˆ°è¾“å‡ºå±‚ï¼Œä¸€æ¬¡é€»è¾‘å›žå½’è¿ç®— è¡Œè¡¨ç¤ºç¥žç»å…ƒä¸ªæ•°ï¼Œåˆ—è¡¨ç¤ºæ ·æœ¬æ•°ç›®m æ¿€æ´»å‡½æ•°ï¼ˆactivation functionï¼‰å¯¹äºŽéšè—å±‚ï¼Œä½¿ç”¨tanhå‡½æ•°è¾ƒå¥½ï¼Œéšè—å±‚çš„è¾“å‡ºè¢«é™å®šåœ¨[-1,1]é—´ï¼Œåœ¨0å€¼é™„è¿‘åˆ†å¸ƒï¼Œå‡å€¼ä¸º0ï¼Œè¿™æ ·ä»Žéšè—å±‚åˆ°è¾“å‡ºå±‚ï¼Œæ•°æ®èµ·åˆ°äº†å½’ä¸€åŒ–çš„æ•ˆæžœã€‚å½“|z|å¾ˆå¤§æ—¶ï¼Œsigmoidå’Œtanhå‡½æ•°çš„æ–œçŽ‡éƒ½å¾ˆå°ï¼Œæ¢¯åº¦ä¸‹é™ç®—æ³•çš„é€Ÿåº¦ä¼šå˜æ…¢ï¼Œæ‰€ä»¥å‡ºçŽ°äº†ReLuå‡½æ•°ã€‚ åå‘ä¼ æ’­ï¼šw[1]å’Œw[2]éƒ½ä¸èƒ½åˆå§‹åŒ–ä¸ºé›¶ï¼Œè‹¥åˆå§‹åŒ–ä¸ºé›¶è¿­ä»£æ›´æ–°ä¼šå¾—åˆ°åŒæ ·çš„ç»“æžœ æ·±å±‚ç¥žç»ç½‘ç»œå°±æ˜¯åŒ…å«æ›´å¤šéšè—å±‚çš„ç¥žç»ç½‘ç»œå¯¹äºŽç¬¬lå±‚ï¼Œæ­£å‘ä¼ æ’­è¿‡ç¨‹å¯ä»¥è¡¨ç¤ºä¸ºï¼šç»´åº¦åˆ†åˆ«ä¸ºï¼š]]></content>
      <categories>
        <category>ngè¯¾ç¨‹ç¬”è®°</category>
      </categories>
      <tags>
        <tag>NN</tag>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå…­ï¼‰]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå…­ï¼‰åº”è¯¥æ˜¯ä¸Šå‘¨åˆ·çš„é¢˜ä¸€ç›´å¿˜è®°å‘äº† 763. Partition Labels1234567891011121314class Solution(object): def partitionLabels(self, S): â€œâ€â€ :type S: str :rtype: List[int] â€œâ€â€ size = [] while S: I = 1 while set(S[I:])&amp;set(S[:I]): I+=1 size.append(i) S=S[I:] return size 806. Number of Lines To Write String123456789101112def numberOfLines(self, widths, S): â€œâ€â€ :type widths: List[int] :type S: str :rtype: List[int] â€œâ€â€ res, cur = 1, 0 for I in S: width = widths[ord(i) - ord(â€˜aâ€™)] res += 1 if cur + width &gt; 100 else 0 cur = width if cur +width &gt; 100 else cur + width return [res, cur] 537. Complex Number Multiplication12345678def complexNumberMultiply(self, a, b): â€œâ€â€ :type a: str :type b: str :rtype: str â€œâ€â€ a, ai, b, bi = map(int, re.findall(â€˜-?\d+â€™, a+b)) return â€˜%d+%diâ€™ % (a*b - ai*bi, a*bi + ai*b) 419. Battleships in a Board12345678910111213141516def countBattleships(self, board): â€œâ€â€ :type board: List[List[str]] :rtype: int â€œâ€â€ total = 0 for I in range(len(board)): for j in range(len(board[0])): if board[I][j] == â€˜Xâ€™: flag = 1 if j&gt;0 and board[I][j-1] == â€˜Xâ€™: flag = 0 if I&gt;0 and board[i-1][j] == â€˜Xâ€™: flag = 0 total += flag return total 821. Shortest Distance to a Character1234567### def shortestToChar(self, S, C):### â€œâ€â€### :type S: str### :type C: str### :rtype: List[int]### â€œâ€â€### return [min(abs(I - j) for j, e in enumerate(S) if e == C) for I in range(len(S))] 530.Minimum Absolute Difference in BST12345678910111213def getMinimumDifference(self, root): â€œâ€â€ :type root: TreeNode :rtype: int â€œâ€â€ def dsf(node, l = []): if node.left: dsf(node.left, l) l.append(node.val) if node.right: dsf(node.right, l) return l l = [1,2,3,4,5] return zip(l,l[1:]) 669. Trim a Binary Search Tree12345678910111213141516 def trimBST(self, root, L, R): â€œâ€â€ :type root: TreeNode :type L: int :type R: int :rtype: TreeNode â€œâ€â€ if not root: return None if L &gt; root.val: return self.trimBST(root.right, L, R) elif R &lt; root.val: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root 513. Find Bottom Left Tree Value123456789def findBottomLeftValue(self, root): â€œâ€â€ :type root: TreeNode :rtype: int â€œâ€â€ q = [root] for node in q: q+=filter(None, (node.right, node.left)) return q 637. Average of Levels in Binary Tree12345678910def dfs(node, depth = 0): if node: if len(info) &lt;= depth: info.append([0,0]) info[depth][0] += node.val info[depth][1] += 1 dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root) return [s/float(c) for s,c in info]]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¸ƒï¼‰]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¸ƒï¼‰æ˜Žå¤©é‡ç‚¹çœ‹çœ‹åŠ¨æ€è§„åˆ’é—®é¢˜ 543. Diameter of Binary Tree123456789101112131415def diameterOfBinaryTree(self, root): â€œâ€â€ :type root: TreeNode :rtype: int â€œâ€â€ self.ans = 0 def depth(node): if not node: return 0 anL, anR = depth(node.right), depth(node.left) self.ans = max(self.ans, anL+anR) return 1+max(anL, anR) depth(root) return self.ans 540. Single Element in a Sorted Array12345678910111213def singleNonDuplicate(self, nums): â€œâ€â€ :type nums: List[int] :rtype: int â€œâ€â€ left, right = 0, len(nums)-1 while left &lt; right: mid = (left + right)/2 if nums[mid] == nums[mid+1]: right = mid + 1 else: left = mid return nums[left] ç„¶é¹…è¶…æ—¶äº†â€¦â€¦ä¸è¿‡å…ˆè¿™æ ·å†™ç€å§ 198. House Robber12345678910 def rob(self, nums): â€œâ€â€ :type nums: List[int] :rtype: int â€œâ€â€ i, j = 0, 0 for m in nums: k, i = i, m + j j = max(k, j) return max(i, j) f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 104. Maximum Depth of Binary Tree12345678def maxDepth(self, root): â€œâ€â€ :type root: TreeNode :rtype: int â€œâ€â€ if not root: return 0 return 1+max(self.maxDepth(root.left), self.maxDepth(root.right))]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäº”ï¼‰]]></title>
    <url>%2F2018%2F05%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäº”ï¼‰å™— 797. All Paths From Source to Target12345678def allPathsSourceTarget(self, graph): def dfs(cur, path): if cur == len(graph) - 1: res.append(path) else: for i in graph[cur]: dfs(i, path + [i]) res = [] dfs(0, [0]) return res 617.Merge Two Binary TreesGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.12345678910111213def mergeTrees(self, t1, t2): &quot;&quot;&quot; :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode &quot;&quot;&quot; if t1 and t2: root = TreeNode(t1.val+t2.val) root.left = self.mergeTrees(t1.left,t2.left) root.right = self.mergeTrees(t1.right,t2.right) return root else: return t1 or t2 728.Self Dividing Numbers12is_self_dividing = lambda num: &apos;0&apos; not in str(num) and all(num % int(digit) == 0 for digit in str(num)) return filter(is_self_dividing, range(left, right + 1)) Subdomain Visit Count123456789101112131415161718def subdomainVisits(self, cpdomains): &quot;&quot;&quot; :type cpdomains: List[str] :rtype: List[str] &quot;&quot;&quot; visits, res = &#123;&#125;, [] for domain in cpdomains: tmp = domain.split() count, doms = int(tmp[0]), tmp[1].split(&apos;.&apos;) for i in range(len(doms)): domain = &apos;.&apos;.join(doms[i:]) if visits.get(domain, 0): visits[domain] += count else: visits[domain] = count for v in visits.items(): res.append(str(v[1]) + &apos; &apos; + v[0]) return res 814.Binary Tree Pruning123456789class Solution: def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root root.left, root.right = self.pruneTree(root.left), self.pruneTree(root.right) return root if root.val == 1 or root.left or root.right else None è¦è®¤çœŸå­¦ä¹ å•Šï¼æ²¡æœ‰ä¹°åˆ°ä¼˜è¡£åº“çš„Tæ¤qwq]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå››ï¼‰]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆå››ï¼‰é“¾è¡¨ 237.Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.12345678class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 725.Split Linked List in Parts1234567891011121314151617181920def splitListToParts(self, root, k): &quot;&quot;&quot; :type root: ListNode :type k: int :rtype: List[ListNode] &quot;&quot;&quot; curr, length = root, 0 while curr: curr, length = curr.next, length + 1 chunk, longer = length//k, length%k res = [chunk + 1]*longer + [chunk]*(k-longer) prev, curr = None, root for index, num in enumerate(res): if prev: prev.next = None res[index] = curr for i in range(num): prev, curr = curr, curr.next return res åˆ†ä¸‰æ­¥ï¼šæ±‚é•¿åº¦ï¼Œåˆ‡å—ï¼ŒæŠŠæ•°æ®è£…è¿›åŽ» 206.Reverse Linked Listè¿­ä»£ä¸å¤ªæ‡‚idâ€¦â€¦12345678def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev é€’å½’123456789def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 445.Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.123456789101112131415161718192021222324def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if not l1: return l2 if not l2: return l1 x1 = x2 = &apos;&apos; while l1: x1 += str(l1.val) l1 = l1.next while l2: x2 += str(l2.val) l2 = l2.next y = int(x1)+int(x2) y = str(y) head = next_node = ListNode(y[0]) for i in range(1, len(y)): next_node.next = ListNode(y[i]) next_node = next_node.next return head 328.Odd Even Linked List1234567891011121314151617def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; d1=odd=ListNode(0) d2=even=ListNode(0) i=1 while head: if i%2: odd.next,odd=head,head else: even.next,even=head,head head=head.next i+=1 odd.next,even.next=d2.next,None return d1.next æ”¾äº”ä¸€äº†å•¦å•¦å•¦]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¸‰ï¼‰]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¸‰ï¼‰ä»Šå¤©é™¤äº†æ•°ç»„éƒ¨åˆ†ï¼Œå†å†™ä¸€ç‚¹é“¾è¡¨å§( Ì€âŒ„ Ì) 695.Max Area of IslandGiven a non-empty 2D array grid of 0â€™s and 1â€™s, an island is a group of 1â€™s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.1234567891011def maxAreaOfIsland(self, grid): m, n = len(grid), len(grid[0]) def dfs(i, j): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j]: grid[i][j] = 0 return 1 + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i + 1, j) + dfs(i, j - 1) return 0 areas = [dfs(i, j) for i in range(m) for j in range(n) if grid[i][j]] return max(areas) if areas else 0 283.Move ZeroesGiven an array nums, write a function to move all 0â€™s to the end of it while maintaining the relative order of the non-zero elements.12345678def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for i in range(nums.count(0)): nums.remove(0) nums.append(0) å¦ä¸€ç§æ–¹æ³•ï¼š123456def moveZeroes(self, nums): zero = 0 # records the position of &quot;0&quot; for i in xrange(len(nums)): if nums[i] != 0: nums[i], nums[zero] = nums[zero], nums[i] zero += 1 667.Beautiful Arrangement IIç®€å•æ¥è¯´å°±æ˜¯ç»™[n,k], ç”Ÿæˆä¸€ä¸ªlistï¼Œå…¶ä¸­æœ‰nä¸ªæ­£æ•´æ•°ï¼Œæ­£æ•´æ•°ç›¸å‡åŽçš„ç»å¯¹å€¼çš„ç»“æžœæœ‰kä¸ªæ­£æ•´æ•°ã€‚1234567891011121314a = [1]h = k+1l = 2for _k in range(k,0,-2): if _k == 1: a.append(h) break else: a.append(h) a.append(l) h -= 1 l += 1a.extend(range(k+2,n+1))return a 495.Teemo Attacking12345678910def findPoisonedDuration(self, tS, d): &quot;&quot;&quot; :type timeSeries: List[int] :type duration: int :rtype: int &quot;&quot;&quot; ans = len(tS)*d for i in range(1, len(tS)): ans -= max(0, d-tS[i]+tS[i-1]) return ans 448. Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.12def findDisappearedNumbers(self, nums): return list(set([i for i in range(1,len(nums)+1)]).difference(set(nums))) å¦å¤–ä¸€ç§æ ‡è®°çš„æ–¹æ³•ï¼š12345for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] &gt; 0] æŒºæœºæ™ºçš„â€¦â€¦ 817.Linked List Components12345678910111213def numComponents(self, head, G): &quot;&quot;&quot; :type head: ListNode :type G: List[int] :rtype: int &quot;&quot;&quot; setG = set(G) res = 0 while head: if head.val in setG and (head.next == None or head.next.val not in setG): res += 1 head = head.next return res ä¸èƒ½æ²‰è¿·å¡žå°”è¾¾ï¼Œè¦å­¦ä¹ ]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€è¿‘çœ‹çš„åŒºå—é“¾çŸ¥è¯†çš„å°è®°å½•]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[1.åŒºå—é“¾çš„å®šä¹‰åŒºå—é“¾æ˜¯ä»¥æ¯”ç‰¹å¸ä¸ºä»£è¡¨çš„æ•°å­—åŠ å¯†è´§å¸ä½“ç³» çš„æ ¸å¿ƒæ”¯æ’‘æŠ€æœ¯. åŒºå—é“¾æŠ€æœ¯çš„æ ¸å¿ƒä¼˜åŠ¿æ˜¯åŽ»ä¸­å¿ƒåŒ–, èƒ½å¤Ÿé€šè¿‡è¿ç”¨æ•°æ®åŠ å¯†ã€æ—¶é—´æˆ³ã€åˆ†å¸ƒå¼å…±è¯†å’Œç»æµŽæ¿€åŠ±ç­‰æ‰‹æ®µ, åœ¨èŠ‚ç‚¹æ— éœ€äº’ç›¸ä¿¡ä»»çš„åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å®žçŽ°åŸºäºŽåŽ»ä¸­å¿ƒåŒ–ä¿¡ç”¨çš„ç‚¹å¯¹ç‚¹äº¤æ˜“ã€åè°ƒä¸Žåä½œ, ä»Žè€Œä¸ºè§£å†³ä¸­å¿ƒåŒ–æœºæž„æ™®éå­˜åœ¨çš„é«˜æˆæœ¬ã€ä½Žæ•ˆçŽ‡å’Œæ•°æ®å­˜å‚¨ä¸å®‰å…¨ç­‰é—®é¢˜æä¾›äº†è§£å†³æ–¹æ¡ˆã€‚ç‰¹ç‚¹ï¼šåŽ»ä¸­å¿ƒåŒ–ã€æ—¶åºæ•°æ®ã€é›†ä½“ç»´æŠ¤ã€å¯ç¼–ç¨‹å’Œå®‰å…¨å¯ä¿¡ åŒºå—é“¾çš„åŸºç¡€æž¶æž„æ¨¡åž‹ æ•°æ®å±‚ï¼šå°è£…åº•å±‚æ•°æ®åŒºå—ä»¥åŠç›¸å…³çš„æ•°æ®åŠ å¯†å’Œæ—¶é—´æˆ³ç­‰æŠ€æœ¯ ç½‘ç»œå±‚ï¼šåŒ…æ‹¬åˆ†å¸ƒå¼ç»„ç½‘æœºåˆ¶ã€æ•°æ®ä¼ æ’­æœºåˆ¶å’Œæ•°æ®éªŒè¯æœºåˆ¶ç­‰ å…±è¯†å±‚ï¼šå°è£…ç½‘ç»œèŠ‚ç‚¹çš„å„ç±»å…±è¯†ç®—æ³• æ¿€åŠ±å±‚ï¼šå°†ç»æµŽå› ç´ é›†æˆåˆ°åŒºå—é“¾æŠ€æœ¯ä½“ç³»ä¸­ï¼Œä¸»è¦åŒ…æ‹¬ç»æµŽæ¿€åŠ±çš„å‘è¡Œæœºåˆ¶å’Œåˆ†é…æœºåˆ¶ åˆçº¦å±‚ï¼šå°è£…å„ç±»è„šæœ¬ã€ç®—æ³•å’Œæ™ºèƒ½åˆçº¦ åº”ç”¨å±‚ï¼šåŒºå—é“¾çš„å„ç§åº”ç”¨åœºæ™¯å’Œæ¡ˆä¾‹ ä¸Šå›¾ä¸ºæ•°æ®åŒºå—çš„ç»“æž„ï¼Œåˆ†ä¸ºåŒºå—å¤´å’ŒåŒºå—ä½“ä¸¤éƒ¨åˆ†ã€‚æœ€å…ˆæ‰¾åˆ°æ­£ç¡®çš„è§£éšæœºæ•°Nonceå¹¶ç»è¿‡å…¨ä½“çŸ¿å·¥éªŒè¯çš„çŸ¿å·¥ä¼šèŽ·å¾—å½“å‰åŒºå—çš„è®°å¸æƒï¼ŒèŽ·å¾—è®°å¸æƒçš„çŸ¿å·¥å°†å½“å‰åŒºå—é“¾æŽ¥åˆ°å‰ä¸€åŒºå—ï¼Œå½¢æˆæœ€æ–°çš„åŒºå—ä¸»é“¾ã€‚ 2.åŒºå—é“¾çš„åˆ†ç±»å…¬å…±é“¾å…¬å…±é“¾å¯¹å¤–å…¬å¼€ï¼Œç”¨æˆ·ä¸ç”¨æ³¨å†Œå°±èƒ½åŒ¿åå‚ä¸Žï¼Œæ— éœ€æŽˆæƒå³å¯è®¿é—®ç½‘ç»œå’ŒåŒºå—é“¾ï¼Œæ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„å®Œå…¨åŽ»ä¸­å¿ƒåŒ–çš„åŒºå—é“¾ï¼Œå¦‚æ¯”ç‰¹å¸å’Œä»¥å¤ªåŠ ä»¥å¤ªåŠä»¥å¤ªåŠï¼ˆEthereumï¼‰æ˜¯ä¸€ä¸ªå¼€æºçš„æœ‰æ™ºèƒ½åˆçº¦åŠŸèƒ½çš„å…¬å…±åŒºå—é“¾å¹³å°ã€‚é€šè¿‡å…¶ä¸“ç”¨åŠ å¯†è´§å¸ä»¥å¤ªå¸ï¼ˆEtherï¼‰æä¾›åŽ»ä¸­å¿ƒåŒ–çš„è™šæ‹Ÿæœºï¼ˆç§°ä¸ºâ€œä»¥å¤ªè™šæ‹Ÿæœºâ€Ethereum Virtual Machineï¼‰æ¥å¤„ç†ç‚¹å¯¹ç‚¹åˆçº¦ã€‚ä»¥å¤ªåŠæ˜¯ä¸ªå¹³å°å’Œç¼–ç¨‹è¯­è¨€ï¼ŒåŒ…æ‹¬æ•°å­—è´§å¸å’Œç”¨æ¥æž„å»ºå’Œå¸†å¸ƒåˆ†å¸ƒå¼åº”ç”¨çš„ä»¥å¤ªè„šæœ¬ï¼Œæ˜¯åŒºå—é“¾ä¸Žæ™ºèƒ½åˆçº¦çš„å®Œç¾Žç»“åˆï¼Œæ‹¥æœ‰ä¸€å¥—å®Œæ•´çš„ã€å¯ä»¥æ‰©å±•å…¶åŠŸèƒ½çš„å·¥å…·ï¼Œåœ¨P2Pç½‘ç»œã€åŠ å¯†ã€HttpClientç­‰æŠ€æœ¯çš„æ”¯æŒä¸‹å®žçŽ°äº†ä¸€ä¸ªç±»ä¼¼äºŽæ¯”ç‰¹å¸çš„åŒºå—é“¾ã€‚ ç¼–ç¨‹è¯­è¨€ï¼šSolidityä»¥å¤ªåŠå…·æœ‰4ç§ä¸“ç”¨è¯­è¨€ï¼šSerpentï¼ˆé•¿å¾—åƒPythonï¼‰ã€Solidityï¼ˆJSï¼‰ã€Mutanï¼ˆGoï¼‰å’ŒLLLï¼ˆLispï¼‰æ™ºèƒ½åˆçº¦çš„é»˜è®¤çš„ç¼–ç¨‹è¯­è¨€æ˜¯Solidityï¼Œæ–‡ä»¶æ‰©å±•åä»¥.solç»“å°¾ã€‚Solidityæ˜¯å’ŒJavaScriptç›¸ä¼¼çš„è¯­è¨€ï¼Œç”¨å®ƒæ¥å¼€å‘åˆçº¦å¹¶ç¼–è¯‘æˆä»¥å¤ªåŠè™šæ‹Ÿæœºå­—èŠ‚ä»£ç ã€‚ è¿è¡ŒçŽ¯å¢ƒï¼šEVMEVMï¼ˆEthereum Virtual Machineï¼‰ä»¥å¤ªåŠè™šæ‹Ÿæœºæ˜¯ä»¥å¤ªåŠä¸­æ™ºèƒ½åˆçº¦çš„è¿è¡ŒçŽ¯å¢ƒã€‚EVMæ˜¯ç”±è®¸å¤šäº’ç›¸è¿žæŽ¥çš„è®¡ç®—æœºç»„æˆçš„ã€‚ä»»ä½•äººéƒ½å¯ä»¥ä¸ºæ‰€æœ‰æƒã€äº¤æ˜“æ ¼å¼å’ŒçŠ¶æ€è½¬åŒ–å‡½æ•°åˆ›å»ºå•†ä¸šé€»è¾‘ã€‚ ä»¥å¤ªåŠè´¦æˆ·ä»¥å¤ªåŠå†…æœ‰ä¸¤ç±»è´¦æˆ·ã€‚å¤–éƒ¨è´¦æˆ·è¢«å…¬é’¥-ç§é’¥å¯¹æŽ§åˆ¶ï¼Œåˆçº¦è´¦æˆ·è¢«å­˜å‚¨åœ¨è´¦æˆ·ä¸­çš„ä»£ç æŽ§åˆ¶ã€‚å¤–éƒ¨è´¦æˆ·æ²¡æœ‰ä»£ç ï¼Œäººä»¬å¯ä»¥é€šè¿‡åˆ›å»ºå’Œç­¾åä¸€ç¬”äº¤æ˜“ä»Žä¸€ä¸ªå¤–éƒ¨è´¦æˆ·å‘é€æ¶ˆæ¯ã€‚æ¯å½“åˆçº¦è´¦æˆ·æ”¶åˆ°ä¸€æ¡æ¶ˆæ¯ï¼Œåˆçº¦å†…éƒ¨çš„ä»£ç å°±ä¼šè¢«æ¿€æ´»ï¼Œå…è®¸å®ƒå¯¹å†…éƒ¨å­˜å‚¨è¿›è¡Œè¯»å–å†™å…¥å‘é€å…¶ä»–æ¶ˆæ¯å’Œåˆ›å»ºåˆçº¦ã€‚ Gasä»¥å¤ªåŠä¸Šçš„æ¯ç¬”äº¤æ˜“éƒ½ä¼šè¢«æ”¶å–ä¸€å®šæ•°é‡çš„ç‡ƒæ–™Gasï¼Œè®¾ç½®Gasçš„ç›®çš„æ˜¯é™åˆ¶äº¤æ˜“æ‰§è¡Œæ‰€éœ€çš„å·¥ä½œé‡ï¼ŒåŒæ—¶ä¸ºäº¤æ˜“çš„æ‰§è¡Œæ”¯ä»˜è´¹ç”¨ã€‚ä»»ä½•ç‰¹å®šçš„åˆçº¦æ‰€éœ€çš„è¿è¡Œåˆçº¦çš„Gasæ•°é‡æ˜¯å›ºå®šçš„ï¼Œç”±åˆçº¦çš„å¤æ‚åº¦å†³å®šã€‚è€ŒGasä»·æ ¼ç”±è¿è¡Œåˆçº¦çš„äººåœ¨æäº¤è¿è¡Œåˆçº¦è¯·æ±‚çš„æ—¶å€™è§„å®šï¼Œä»¥ç¡®å®šä»–æ„¿æ„ä¸ºè¿™æ¬¡äº¤æ˜“æ„¿æ„ä»˜å‡ºçš„è´¹ç”¨ï¼šGasä»·æ ¼ï¼ˆç”¨ä»¥å¤ªå¸è®¡ä»·ï¼‰ * Gasæ•°é‡ã€‚ ä»¥å¤ªåŠå®¢æˆ·ç«¯ç›®å‰æœ‰Goè¯­è¨€å®žçŽ°çš„å®¢æˆ·ç«¯Gethï¼Œç”¨C++å®žçŽ°çš„å®¢æˆ·ç«¯Ethï¼ŒPythonå®žçŽ°çš„å®¢æˆ·ç«¯Pyethappå’ŒJavaå®žçŽ°çš„å®¢æˆ·ç«¯EthereumJã€‚ä»¥å¤ªåŠåŒ…æ‹¬ä¸€ä¸ªä¸“ç”¨çš„å®¢æˆ·ç«¯æµè§ˆå™¨ï¼Œä½¿å¾—ç”¨æˆ·å¯ä»¥è¿è¡Œå„ç§å„æ ·çš„åŽ»ä¸­å¿ƒåŒ–åº”ç”¨ï¼ˆDAppï¼‰ï¼Œå‘å¸ƒæ™ºèƒ½åˆçº¦ï¼Œè¿™ä¸€ç±»æµè§ˆå™¨è¢«ç§°ä¸ºMistã€‚Mistç”±ç‰¹æ®Šçš„å®‰å…¨å±‚ã€å¯†åŒ™ç®¡ç†ã€åŽ»ä¸­å¿ƒåŒ–è´¦æˆ·ç®¡ç†å’Œä¸ŽåŒºå—é“¾ç›¸å…³çš„ç»„ä»¶å‡ éƒ¨åˆ†ç»„æˆã€‚ä»Žç”¨æˆ·ä½“éªŒè§’åº¦è€Œè¨€ï¼Œå¯ä»¥åœ¨Mistä¸­ä½¿ç”¨DAppï¼Œå°±åƒé€šè¿‡å¸¸è§„æµè§ˆå™¨ä¸Žç½‘ç«™è¿›è¡Œäº¤äº’ä¸€æ ·ã€‚ åº”ç”¨Augurï¼ˆAugur - Homeï¼‰ä¸€ä¸ªåŽ»ä¸­å¿ƒåŒ–é¢„æµ‹ç³»ç»ŸMakerï¼ˆMakerDAO - Stability for the blockchainï¼‰ä¸€ä¸ªé‡‘èžç±»åŽ»ä¸­å¿ƒåŒ–è‡ªæ²»ç»„ç»‡ è”ç›Ÿé“¾è”ç›Ÿé“¾ä»…é™äºŽè”ç›Ÿæˆå‘˜å‚ä¸Žï¼ŒåŒºå—é“¾ä¸Šçš„è¯»å†™æƒé™ã€å‚ä¸Žè®°è´¦æƒé™æŒ‰ç…§è”ç›Ÿè§„åˆ™æ¥åˆ¶å®šï¼Œå¦‚åŒºå—é“¾è”ç›ŸR3å’Œè¶…çº§è´¦æœ¬ï¼ˆhyperlederï¼‰ã€‚ è¶…çº§è´¦æœ¬ï¼ˆ Hyperledgerï¼‰è¶…çº§è´¦æœ¬é¡¹ç›®æ˜¯ç”±LinuxåŸºé‡‘ä¼šäºŽ2015å¹´12æœˆå¯åŠ¨çš„å¼€æºé¡¹ç›®ï¼Œæ—¨åœ¨æŽ¨åŠ¨å„æ–¹åä½œï¼Œå…±åŒæ‰“é€ æœºé‡åŒºå—é“¾çš„ä¼ä¸šçº§åˆ†å¸ƒå¼è´¦æœ¬åº•å±‚æŠ€æœ¯ï¼Œç”¨äºŽæž„å»ºæ”¯æ’‘ä¸šåŠ¡çš„è¡Œä¸šåº”ç”¨å’Œå¹³å°ã€‚è¶…çº§è´¦æœ¬æ˜¯ç”±å¤§ä¼ä¸šé¢†è¡”çš„å•†ä¸šåŒ–è”ç›Ÿé“¾é¡¹ç›®ã€‚ é¡¹ç›®ç®¡ç†å½¢å¼ç†äº‹ä¼šï¼šè´Ÿè´£æ—¥å¸¸äº‹åŠ¡ç®¡ç†ï¼ŒåŒ…æ‹¬å®¡æ ¸é¢„ç®—ã€ç›‘ç£é¡¹ç›®å’Œå¸‚åœºæ´»åŠ¨ã€è¡¨å†³é‡è¦äº‹é¡¹ç­‰èŒè´£ã€‚æŠ€æœ¯æŒ‡å¯¼å§”å‘˜ä¼šï¼šé¡¹ç›®çš„è´¡çŒ®è€…æˆ–ç»´æŠ¤è€…é€‰ä¸¾äº§ç”Ÿï¼Œä¸»è¦ä»»åŠ¡æ˜¯åœ¨æŠ€æœ¯ä¸Šä¿è¯é¡¹ç›®æ­£å¸¸è¿›è¡Œï¼ŒåŒ…æ‹¬åˆ¶å®šæŠ€æœ¯æ–¹å‘ã€å®¡æ‰¹é¡¹ç›®è®®æ¡ˆç­‰ã€‚ä»»ä½•è´¡çŒ®ä»£ç ã€æ–‡æ¡£ç­‰æŠ€æœ¯æ€§äº§å“çš„äººéƒ½å¯ä»¥ç§°ä¸ºè´¡çŒ®è€…ã€‚å¸‚åœºå§”å‘˜ä¼šç”¨æˆ·é¡¾é—®å›¢ FabricFabricä¸ºåº”ç”¨æä¾›äº†gRPC APIï¼Œä»¥åŠå°è£…APIçš„SDKä¾›åº”ç”¨è°ƒç”¨ã€‚åº”ç”¨å¯ä»¥é€šè¿‡SDKè®¿é—®Fabricç½‘ç»œä¸­çš„å¤šç§èµ„æºï¼ŒåŒ…æ‹¬è´¦æœ¬ã€äº¤æ˜“ã€é“¾ç ã€äº‹ä»¶ã€æƒé™ç®¡ç†ç­‰ã€‚åº”ç”¨å¼€å‘è€…åªéœ€è¦è·Ÿè¿™äº›èµ„æºæ‰“äº¤é“å³å¯ï¼Œæ— éœ€å…³å¿ƒå¦‚ä½•å®žçŽ°ã€‚å…¶ä¸­ï¼Œè´¦æœ¬æ˜¯æœ€æ ¸å¿ƒçš„ç»“æž„ï¼Œè®°å½•åº”ç”¨ä¿¡æ¯ï¼Œåº”ç”¨åˆ™é€šè¿‡å‘èµ·äº¤æ˜“æ¥å‘è´¦æœ¬ä¸­è®°å½•æ•°æ®ã€‚äº¤æ˜“æ‰§è¡Œçš„é€»è¾‘é€šè¿‡é“¾ç æ¥æ‰¿è½½ã€‚æ•´ä¸ªç½‘ç»œè¿è¡Œä¸­å‘ç”Ÿçš„äº‹ä»¶å¯ä»¥è¢«åº”ç”¨è®¿é—®ï¼Œä»¥è§¦å‘å¤–éƒ¨æµç¨‹ç”šè‡³å…¶ä»–ç³»ç»Ÿã€‚æƒé™ç®¡ç†åˆ™è´Ÿè´£æ•´ä¸ªè¿‡ç¨‹ä¸­çš„è®¿é—®æŽ§åˆ¶ã€‚è´¦æœ¬å’Œäº¤æ˜“è¿›ä¸€æ­¥åœ°ä¾èµ–æ ¸å¿ƒçš„åŒºå—é“¾ç»“æž„ã€æ•°æ®åº“ã€å…±è¯†æœºåˆ¶ç­‰æŠ€æœ¯ï¼›é“¾ç åˆ™ä¾èµ–å®¹å™¨ã€çŠ¶æ€æœºç­‰æŠ€æœ¯ï¼›æƒé™ç®¡ç†åˆ©ç”¨äº†å·²æœ‰çš„PKIä½“ç³»ã€æ•°å­—è¯ä¹¦ã€åŠ è§£å¯†ç®—æ³•ç­‰è¯¸å¤šå®‰å…¨æŠ€æœ¯ã€‚åº•å±‚ç”±å¤šä¸ªèŠ‚ç‚¹ç»„æˆP2Pç½‘ç»œï¼Œé€šè¿‡gRPCé€šé“è¿›è¡Œäº¤äº’ï¼Œåˆ©ç”¨Gossipåè®®è¿›è¡ŒåŒæ­¥ã€‚Fabricä¾§é‡äºŽæƒé™æŽ§åˆ¶ã€ç§å¯†æ€§ä¿æŠ¤å’Œäº¤æ˜“æ€§èƒ½æé«˜ã€‚ Sawtooth Lakeè¿™ä¸ªå·¥ç¨‹ç§°ä¸ºâ€é”¯é½¿æ¹–â€ï¼Œå¯¹äºŽåˆ›å»ºï¼Œéƒ¨ç½²å’Œè¿è¡Œåˆ†å¸ƒå¼è´¦æœ¬æ¥è¯´å®ƒæ˜¯ä¸€ä¸ªé«˜åº¦æ¨¡å—åŒ–å¹³å°çš„å·¥ç¨‹ï¼Œåˆ†å¸ƒå¼è´¦æœ¬æä¾›æ•°æ®è®°å½•ç»´æŠ¤ä¸€ä¸ªåŽ»ä¸­å¿ƒåŒ–æƒå¨å’Œå®žçŽ°ã€‚ä»£æ›¿å•ä¸ªé›†ä¸­å¼æ•°æ®åº“ï¼Œåˆ†å¸ƒå¼å¸æœ¬ä¸­çš„å‚ä¸Žè€…ä¸ºå…±äº«è®¡ç®—è´¡çŒ®èµ„æºï¼Œç¡®ä¿å¯¹åˆ†å¸ƒå¼å¸æœ¬çš„çŠ¶æ€çš„æ™®éä¸€è‡´ã€‚æ¯”ç‰¹å¸æ˜¯æœ€æµè¡Œçš„åˆ†å¸ƒå¼åˆ†å¸æœ¬ï¼Œè¯¥æŠ€æœ¯å·²ç»è¢«æè®®ç”¨äºŽå›½é™…æ±‡æ¬¾ï¼Œä¿é™©ç´¢èµ”å¤„ç†ï¼Œä¾›åº”é“¾ç®¡ç†å’Œç‰©è”ç½‘ï¼ˆIoTï¼‰çš„è®¸å¤šä¸åŒçš„åº”ç”¨åœºæ™¯ã€‚åœ¨é”¯é½¿æ¹–é¡¹ç›®ä¸­çš„åˆ†å¸ƒå¼è´¦æœ¬åŒ…æ‹¬3ä¸ªç»„ä»¶ï¼šä»£è¡¨è´¦æœ¬çŠ¶æ€çš„æ•°æ®æ¨¡åž‹ï¼›æ”¹å˜è´¦æœ¬çŠ¶æ€çš„äº¤æ˜“è¯­è¨€ï¼›åœ¨å‚ä¸Žè€…ä¹‹é—´å»ºç«‹äº¤æ˜“ç»“æžœå…±è¯†çš„åè®®ã€‚é”¯é½¿æ¹–ä¾§é‡äºŽæä¾›å®Œæ•´çš„äº¤æ˜“å®¶æ—å’ŒèŠ‚èƒ½çš„å…±è¯†ç®—æ³•ã€‚Fabricå’ŒSawtoothéƒ½æä¾›äº†åˆ†å¸ƒå¼è´¦æœ¬çš„å®žçŽ°ã€‚ IrohaIrohaå¯ä»¥å®Œå–„Fabricã€é”¯é½¿æ¹–å’Œå…¶ä»–æœ‰æ½œåŠ›çš„é¡¹ç›®ï¼Œé€šè¿‡ç”¨C++åˆ›é€ å¯é‡å¤ä½¿ç”¨çš„è¦ç´ ï¼Œèƒ½è¢«GOä¸€ç±»çš„è¯­è¨€ç¼–è¯‘ã€‚é€šè¿‡è¿™ç§æ–¹æ³•ï¼ŒIrohaèƒ½èžå…¥çŽ°æœ‰é¡¹ç›®ï¼Œå…¶é•¿æœŸç›®æ ‡æ˜¯å®žçŽ°ä¸€ä¸ªå¥å…¨èµ„æºåº“ï¼Œè¶…çº§è´¦æœ¬æŠ€æœ¯é¡¹ç›®åœ¨è¿è¡Œåˆ†å¸ƒå¼è´¦æœ¬æ—¶ï¼Œèƒ½è‡ªç”±åœ°é€‰æ‹©å¹¶ä½¿ç”¨è¿™äº›å¯é‡å¤ä½¿ç”¨çš„å…ƒç´ ã€‚å°½ç®¡é€šè¿‡javaï¼ˆè¿è¡ŒJVMæ²™ç›’ï¼‰çš„chaincodeå®Œå–„æ™ºèƒ½åˆçº¦ä¹Ÿæ˜¯å¯è¡Œçš„ï¼Œä½†Irohaçš„ç”¨æˆ·ä¸éœ€è¦å†™chaincodeæ¥ç¡®å®šæ•°å­—èµ„äº§ã€‚ä½¿ç”¨è´§å¸å’Œå‘çŸ­ä¿¡è¿™æ ·çš„æ™®é€šåœºæ™¯ä¹Ÿæ˜¯æ ¸å¿ƒæž„æž¶çš„ä¸€éƒ¨åˆ†ã€‚ BurrowBurrowæ˜¯ä¸€ç§ä»Žä»¥å¤ªåŠè¡ç”Ÿå‡ºæ¥çš„ä»£ç åº“ï¼Œçµæ„Ÿæ¥è‡ªäºŽMonaxåœ¨2014å¹´å¼€å‘å’Œå¼€æºçš„ä¸€ç§å«åšeris-dbçš„æŠ€æœ¯ã€‚è¯¥é¡¹ç›®ç”±è‹±ç‰¹å°”å’ŒMonaxæå‡ºï¼Œä¸ºå•†ä¸šå…¬å¸å’Œç»„ç»‡æä¾›äº†ä¸€ä¸ªæ™ºèƒ½åˆçº¦å¹³å°ã€‚ ä¾æ‰˜ä»¥å¤ªåŠå¼ºå¤§çš„å¼€å‘æ¡†æž¶å’Œçµæ´»çš„åŽ»ä¸­å¿ƒåŒ–åº”ç”¨ç”Ÿæ€ç³»ç»Ÿï¼ŒBurrowå°†ä¼šæä¾›ä¸€ç§å¿…è¦çš„åŸºç¡€è®¾æ–½ç»™é‚£äº›å¯»æ±‚åˆ©ç”¨åŸºäºŽåŒºå—é“¾çš„æ™ºèƒ½åˆçº¦ç”¨äºŽå•†ä¸šè¿è¥çš„ä¼ä¸šå’Œè¶…çº§è´¦æœ¬æˆå‘˜ã€‚ ç§æœ‰é“¾ç§æœ‰é“¾ä»…åœ¨ç§æœ‰ç»„ç»‡ä½¿ç”¨ï¼ŒåŒºå—é“¾ä¸Šçš„è¯»å†™æƒé™ã€å‚ä¸Žè®°è´¦æƒé™æŒ‰ç§æœ‰ç»„ç»‡è§„åˆ™åˆ¶å®šï¼Œä¸€èˆ¬æ˜¯ä¼ä¸šå†…éƒ¨çš„åº”ç”¨ã€‚ ä¾§é“¾èƒ½å’Œæ¯”ç‰¹å¸åŒºå—é“¾äº¤äº’ï¼Œå¹¶ä¸Žæ¯”ç‰¹å¸æŒ‚é’©çš„åŒºå—é“¾ã€‚æ¯”ç‰¹å¸æ˜¯å¤§å®¶å…¬è®¤çš„å…¬å…±é“¾ï¼Œä½†è§„åˆ™ç›¸å¯¹å›ºå®šï¼Œäº¤æ˜“é€Ÿåº¦è¾ƒæ…¢ï¼Œæ‰€ä»¥é€šè¿‡ä¾§é“¾æé«˜æ•ˆçŽ‡æ˜¯ä¸€ä¸ªæœ‰æ•ˆåšæ³•ã€‚ äº’è”é“¾é’ˆå¯¹ç‰¹å®šé¢†åŸŸçš„åº”ç”¨å¯èƒ½ä¼šå½¢æˆå„è‡ªåž‚ç›´é¢†åŸŸçš„åŒºå—é“¾ï¼Œè¿™äº›åŒºå—é“¾ä¼šæœ‰äº’è”äº’é€šçš„éœ€æ±‚ï¼Œé€šè¿‡æŸç§äº’è”äº’é€šåè®®è¿žæŽ¥èµ·æ¥ï¼Œå½¢æˆåŒºå—é“¾å…¨çƒç½‘ç»œ 3.åŸºäºŽæ¯”ç‰¹å¸çš„æ–¹æ¡ˆé—ªç”µç½‘ç»œé—ªç”µç½‘ç»œï¼ˆLightning Networkï¼‰æ˜¯ä¸€ä¸ªåŽ»ä¸­å¿ƒåŒ–çš„ç³»ç»Ÿã€‚é—ªç”µç½‘ç»œçš„å“è¶Šä¹‹å¤„åœ¨äºŽï¼Œæ— éœ€ä¿¡ä»»å¯¹æ–¹ä»¥åŠç¬¬ä¸‰æ–¹å³å¯å®žçŽ°å®žæ—¶çš„ã€æµ·é‡çš„äº¤æ˜“ç½‘ç»œã€‚å®ƒåˆ©ç”¨äº†äº†æ¯”ç‰¹å¸çš„å®‰å…¨ç‰¹æ€§ï¼Œåœ¨çº¿ä¸‹æä¾›é«˜é€Ÿçš„å®žæ—¶äº¤æ˜“å¤„ç†èƒ½åŠ›ã€‚ç”¨æˆ·æ—¢å¯ä»¥é€šè¿‡ç‚¹å¯¹ç‚¹çš„ç›´æŽ¥æ”¯ä»˜æ–¹å¼ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ç½‘ç»œè·¯ç”±çš„æ–¹å¼å®žçŽ°é—´æŽ¥æ”¯ä»˜ã€‚é—ªç”µç½‘ç»œçš„å…³é”®æŠ€æœ¯æœ‰ä¸‰ï¼ŒåŽåŽä¾èµ–äºŽå‰å‰ï¼Œä¾æ¬¡æ˜¯ï¼šRSMCï¼ŒHTLCå’Œé—ªç”µç½‘ç»œã€‚æŠ€æœ¯å®žçŽ°è™½ç„¶å¤æ‚ï¼Œä½†æœ¬è´¨å´å¾ˆç®€å•ã€‚RSMCï¼šé—ªç”µç½‘ç»œçš„åŸºç¡€æ˜¯äº¤æ˜“åŒæ–¹ä¹‹é—´çš„åŒå‘å¾®æ”¯ä»˜é€šé“ï¼ŒRSMCï¼ˆRecoverable Sequence Maturity Contractï¼‰å®šä¹‰äº†è¯¥åŒå‘å¾®æ”¯ä»˜é€šé“çš„æœ€åŸºæœ¬å·¥ä½œæ–¹å¼ã€‚HTLCï¼š RSMCåªæ”¯æŒæœ€ç®€å•çš„æ— æ¡ä»¶èµ„é‡‘æ”¯ä»˜ï¼ŒHTLCï¼ˆHashed Timelock Contractï¼‰è¿›ä¸€æ­¥å®žçŽ°äº†æœ‰æ¡ä»¶çš„èµ„é‡‘æ”¯ä»˜ï¼Œé€šé“ä½™é¢çš„åˆ†é…æ–¹å¼ä¹Ÿå› æ­¤å˜å¾—æ›´ä¸ºå¤æ‚ã€‚RSMCé€šè¿‡å·§å¦™çš„è®¾ç½®Commitment TXçš„å¤šé‡ç­¾åè¾“å‡ºï¼Œä»¥åŠsequenceçš„å»¶è¿Ÿè¿›å—å½¢æˆæƒ©ç½šçª—å£æœŸï¼Œè§£å†³äº†åœ¨å¾®æ”¯ä»˜é€šé“ä¸­çš„å¸å•å‘æµåŠ¨é—®é¢˜ã€‚ é›·ç”µç½‘ç»œRAIDENç½‘ç»œæ˜¯ä¸€ä¸ªç¦»é“¾è§„æ¨¡çš„è§£å†³æ–¹æ¡ˆï¼Œä½¿è¿‘å³æ—¶ï¼Œä½Žè´¹ç”¨å’Œå¯æ‰©å±•çš„æ”¯ä»˜ã€‚æ˜¯ä»¥å¤ªåŠç¤¾åŒºæå‡ºçš„é“¾ä¸‹å¾®æ”¯ä»˜é€šé“è§£å†³æ–¹æ¡ˆã€‚Aå‘Dè½¬è´¦ï¼Œç»ç”±Bå’ŒCçš„æ”¯ä»˜é€šé“ä¸­ä»‹ã€‚Aæž„é€ ç”±secretè§£é”çš„å“ˆå¸Œé”å‘Bè½¬è´¦ï¼Œç”±Bå’ŒCæŒ‰åŒæ ·çš„secretè§£é”æ¡ä»¶ä¾æ¬¡æž„é€ å‘Cå’ŒDçš„å“ˆå¸Œé”è½¬è´¦ã€‚ç„¶åŽAå‘Dæä¾›è§£é”çš„secretã€‚Då‘Cå‡ºç¤ºsecretï¼Œæ‹¿åˆ°å“ˆå¸Œé”è½¬è´¦ä¸­è¢«é”å®šçš„ä»£å¸ï¼Œå¹¶å¾—åˆ°Cå‘Dè½¬è´¦çš„ä½™é¢è¯æ˜Žã€‚æœ€åŽCå’ŒBé‡å¤æ­¤æ“ä½œã€‚äº¤æ˜“åŒæ–¹åªè¦åœ¨é“¾ä¸Šå­˜åœ¨äº¤æ˜“é€šé“ï¼Œå°±èƒ½åœ¨é“¾ä¸‹åŸºäºŽè¢«é”å®šçš„ä½™é¢è¿›è¡Œé«˜é¢‘ã€åŒå‘çš„å³æ—¶ç¡®è®¤äº¤æ˜“ã€‚å¤šä¸ªé€šé“å½¢æˆçš„æ”¯ä»˜è·¯å¾„æž„æˆâ€œé›·ç”µç½‘ç»œâ€ã€‚ 4.æ€»ç»“è¿™å‡ å¤©é˜…è¯»äº†ä¸€äº›åšå®¢å’Œã€ŠåŒºå—é“¾æŠ€æœ¯æŒ‡å—ã€‹ï¼Œäº†è§£åˆ°åŒºå—é“¾çš„ä¸€äº›åº”ç”¨ã€‚åŒºå—é“¾ç›®å‰å‘¼å£°å¾ˆé«˜ï¼Œç‚™æ‰‹å¯çƒ­ï¼Œå¸Œæœ›ä»¥åŽèƒ½æœ‰æ›´åŠ æ·±å…¥çš„å­¦ä¹ ã€‚ ä»¥å¤ªåŠæ˜¯ä»€ä¹ˆ - ä»¥å¤ªåŠå¼€å‘å…¥é—¨æŒ‡å— - Tinyç†Š - åšå®¢å›­è¢å‹‡, &amp; çŽ‹é£žè·ƒ. (2016). åŒºå—é“¾æŠ€æœ¯å‘å±•çŽ°çŠ¶ä¸Žå±•æœ›. è‡ªåŠ¨åŒ–å­¦æŠ¥, 42(4), 481-494.è¶…çº§è´¦æœ¬Fabricçš„æž¶æž„ä¸Žè®¾è®¡ - CSDNåšå®¢Fabric Â· GitHubhttps://github.com/hyperledgeråŒºå—é“¾æŠ€æœ¯æŒ‡å—.é‚¹å‡è¯¦è§£æœ€è¿‘å¤§çƒ­çš„é—ªç”µç½‘ç»œã€é›·ç”µç½‘ç»œå’ŒCORDAå·´æ¯”ç‰¹æœåŠ¡äºŽåŒºå—é“¾åˆ›æ–°è€…é—ªç”µç½‘ç»œå’Œé›·ç”µç½‘ç»œè¯¦è§£GitHub - raiden-network/raiden: Raiden Network]]></content>
      <categories>
        <category>åŒºå—é“¾</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•(äºŒ)]]></title>
    <url>%2F2018%2F04%2F20%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒï¼‰çœ‹ä¹¦çœ‹åˆ°æ•°ç»„ä»Šå¤©å°±åˆ·ä¸‹æ•°ç»„å§ã€‚ä»Šå¤©ä¸Šç½‘é¡µç¼–ç¨‹è¯¾å­¦JSä¹Ÿæ˜¯ä¸€è¨€éš¾å°½â€¦â€¦ 561.Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), â€¦, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) list.sort()åœ¨python3é‡Œåªæœ‰keyå’Œreverseä¸¤ä¸ªå‚æ•°äº†ã€‚ 566.Reshape the MatrixYouâ€™re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.ç¬¬ä¸€ç§ç”¨numpyçš„æ–¹æ³•ï¼š1234567891011def matrixReshape(self, nums, r, c): &quot;&quot;&quot; :type nums: List[List[int]] :type r: int :type c: int :rtype: List[List[int]] &quot;&quot;&quot; try: return np.reshape(nums,(r,c)).tolist() except: return nums ç¬¬äºŒç§123456def matrixReshape(self, nums, r, c): flat = sum(nums, []) if len(flat) != r * c: return nums tuples = zip(*([iter(flat)] * c)) return map(list, tuples) 766.Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.123456def isToeplitzMatrix(self, m): for i in range(len(m)-1): for j in range(len(m[0])-1): if m[i][j] != m[i+1][j+1]: return False return True 485.Max Consecutive Ones1234567891011def findMaxConsecutiveOnes(self, nums): maxc = 0 count = 0 for i in nums: if i == 1: count = count +1 else: maxc = max(maxc, count) count = 0 maxc = max(maxc, count) return maxc è¿™é“é¢˜æƒ³è¿‡å°†listè½¬strï¼Œä½†æ˜¯æ„Ÿè§‰ä¼šå¾ˆæ…¢è€Œä¸”æ²¡æœ‰å†™å‡ºæ¥ ( Â´â–½ï½€)æƒ³åƒèžºç‹®ç²‰]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeåˆ·é¢˜è®°å½•(ä¸€)]]></title>
    <url>%2F2018%2F04%2F17%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeåˆ·é¢˜è®°å½•ï¼ˆä¸€ï¼‰ä¸ºäº†åŠ å¼ºåŸºç¡€å†³å®šåˆ·é¢˜ï¼Œä»Žleetcodeçš„ç®€å•å¼€å§‹ï¼Œä¹Ÿæ˜¯å¯¹æ•°æ®ç»“æž„çš„å¤ä¹ å·©å›ºã€‚ 557.Reverse Words in a String IIIGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. 12def reverseWords(self, s): return &apos; &apos;.join(i[::-1] for i in s.split()) å¦å¤–åœ¨è®¨è®ºåŒºçœ‹åˆ°ä¸€ç§è§£å†³æ–¹æ¡ˆï¼š12def reverseWords(self, s): return &apos; &apos;.join(s.split()[::-1])[::-1] 344. Reverse StringWrite a function that takes a string as input and returns the string reversed.12def reverseString(self, s): return s[::-1] 819.Most Common Word1234567891011from collections import Counterimport reclass Solution(object): def mostCommonWord(self, paragraph, banned): words = Counter(re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, paragraph).lower().split()) ban = set(banned) for i in ban: if i in words: del words[i] words = words.most_common() return (words)[0][0] PS.12345def mostCommonWord(self, p, banned): words = re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, p).lower().split() res = collections.Counter(words).most_common() ban = set(banned) return iter(w for w, n in res if w not in ban).next() iter()å‡½æ•°èŽ·å–è¿­ä»£å™¨ï¼Œå¯¹èŽ·å–åˆ°çš„è¿­ä»£å™¨ä½¿ç”¨next()å‡½æ•°æ¥èŽ·å–ä¸‹ä¸€æ¡æ•°æ® åˆšå¼€å§‹åˆ·é¢˜æ¯”è¾ƒéš¾äº†ï¼Œå¸Œæœ›ä»¥åŽèƒ½å¤Ÿæ›´ç†Ÿç»ƒå§]]></content>
      <categories>
        <category>æ—¥å¸¸åˆ·é¢˜</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
