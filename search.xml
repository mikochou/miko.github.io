<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂçÅ‰∏âÔºâ]]></title>
    <url>%2F2019%2F03%2F06%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[leetcodeÂà∑È¢òËÆ∞ÂΩï(ÂçÅ‰∏â)ÊØïËÆæÂíãÂäûÂïä 141.Linked List Cycle123456789101112131415def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head == None: return False m1 = head m2 = head.next while m2 != None and m2.next != None: m1 = m1.next m2 = m2.next.next if m2 is m1: return True return False 137.Single Number II12345one, two = 0, 0 for x in nums: one, two, three = one ^ x, two | (one &amp; x), two &amp; x one, two = one &amp; ~three, two &amp; ~three return one 674.Longest Continuous Increasing Subsequence12345678910111213if not nums: return 0 l = len(nums) if l &lt;=1 : return 1 res = 1 max1 = 1 for i in range(1,l): if i and nums[i-1] &lt; nums[i]: res +=1 if res &gt; max1: max1 = res else: res = 1 return max1 961.N-Repeated Element in Size 2N Array123456a = [] for i in A: if i not in a: a += [i] else: return i 448.Find All Numbers Disappeared in an ArrayÊ†áËÆ∞Âá∫Áé∞‰∫ÜÁöÑÊï∞Â≠ó‰∏∫Ë¥üÊï∞1234for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = -abs(nums[index]) return [index for index,n in enumerate(nums,start=1) if n &gt; 0] 257.Binary Tree Paths123456789def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] if not root.left and not root.right: return [str(root.val)] return [str(root.val)+&apos;-&gt;&apos;+i for i in self.binaryTreePaths(root.left)] + [str(root.val) + &apos;-&gt;&apos; + i for i in self.binaryTreePaths(root.right)] 160.Intersection of Two Linked Lists123456789101112131415161718curA, curB = headA, headB lenA,lenB = 0,0 while curA: lenA += 1 curA = curA.next while curB: lenB += 1 curB = curB.next curA, curB = headA, headB if lenA &gt;= lenB: for i in range(abs(lenA-lenB)): curA = curA.next else: for i in range(abs(lenA-lenB)): curB = curB.next while curB != curA: curA,curB = curA.next,curB.next return curA 162.Find Peak Element123456789101112l = 0 r = len(nums) - 1 while l &lt; r: mid = (r+l)/2 if nums[mid]&gt;nums[mid+1] and nums[mid] &gt; nums[mid-1]: return mid if nums[mid] &lt; nums[mid + 1]: l = mid + 1 else: r = mid - 1 return l 83.Remove Duplicates from Sorted List12345678910111213if head == None: return head cur = head.next pre = head while cur != None: if cur.val == pre.val: pre.next = cur.next cur = cur.next else: cur = cur.next pre = pre.next return head 539.Minimum Time Difference1234567def minutes(p): h,m = map(int,p.split(&apos;:&apos;)) return 60*h+m mins = sorted(map(minutes,timePoints)) mins.append(60*24 + mins[0]) return min(b-a for a,b in zip(mins,mins[1:])) 506.Relative Ranks123sort = sorted(nums)[::-1] rank = [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;]+map(str,range(4,len(nums)+1)) return map(dict(zip(sort,rank)).get,nums) 402.Remove K Digits12345678def shrink(num): a = len(num) for i in range(a - 1): if num[i] &gt; num[i+1]: return num[:i]+num[i+1:]for i in range(k): num = shrink(num)return str(int(num)) if num else &quot;0&quot; 404.Sum of Left Leaves123456789self.sum = 0 def dfs(root): if root: if root.left and not root.left.left and not root.left.right: self.sum += root.left.val dfs(root.left) dfs(root.right) dfs(root) return self.sum]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂçÅ‰∫åÔºâ]]></title>
    <url>%2F2019%2F03%2F03%2Fleetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[leetcodeÂà∑È¢òËÆ∞ÂΩï(ÂçÅ‰∫å)Ëèú 33.Search in Rotated Sorted ArrayÁî®‰∫åÂàÜÊü•Êâæ1234567891011121314151617181920212223242526def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return -1 low, high = 0, len(nums)-1 while low &lt;= high: mid = (low+high)&gt;&gt;1 if target== nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 35.Search Insert PositionÂõ†‰∏∫ÊòØsortedÊâÄ‰ª•Áî®‰∫åÂàÜÊü•Êâæ123456789101112131415161718class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; low = 0 high = len(nums) - 1 while low&lt;=high: mid = (low+high)//2 if nums[mid] == target: return mid if nums[mid] &gt; target: high = mid - 1 if nums[mid] &lt; target: low = mid + 1 return ((high+low)//2 + 1) ÂÖ∂ÂÆûÂàöÂºÄÂßãÊÉ≥Âà∞ÁöÑÊòØ‰∏Ä‰∏™ÂæàÊÖ¢ÁöÑÊñπÊ≥ï-&gt;123nums.append(target)nums.sort()return nums.index(target) 39.Combination Sumdfs123456789101112res = [] def dfs(target, index, path): if target &lt; 0: return if target == 0: res.append(path) return for i in range(index,len(candidates)): dfs(target-candidates[i],i,path+[candidates[i]]) dfs(target,0,[]) return res 53.Maximum Subarray123456cur = maxs = -float(&apos;inf&apos;) for i in xrange(len(nums)): cur +=nums[i] cur = max(cur,nums[i]) maxs = max(maxs,cur) return maxs 538.Convert BST to Greater Tree12345678910111213a = 0 def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return None self.convertBST(root.right) self.a += root.val root.val = self.a self.convertBST(root.left) return root 860.Lemonade Change12345678910111213141516five, ten = 0, 0 for i in bills: if i == 5: five+=1 elif i == 10: five -=1 ten +=1 else: if ten &gt; 0: five -=1 ten -=1 else: five -=3 if five &lt; 0: return False return True 100.Same Tree123456if p == None and q == None: return True if p and q: return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) else: return False 594.Longest Harmonious Subsequence12345678910111213141516def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in nums: if i not in m: m[i] = 1 else: m[i] += 1 l = 0 for i in m: if m.get(i+1): l = max(l,m[i]+m[i+1]) return l 671.Second Minimum Node In a Binary Tree1234567891011121314151617def findSecondMinimumValue(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = float(&apos;inf&apos;) minx = root.val def dfs(node): if node: if minx&lt;node.val&lt;self.ans: self.ans = node.val elif node.val == minx: dfs(node.left) dfs(node.right) dfs(root) return self.ans if self.ans &lt; float(&apos;inf&apos;) else -1 152.Maximum Product SubarrayÊôÆÈÄöÊñπÊ≥ï1234567max1 = big = small = nums[0] for i in nums[1:]: temp = big big = max(i,i*big,i*small) small = min(i,i*temp,i*small) max1 = max(max1,big) return max1 Âú®ËÆ®ËÆ∫ÈáåÁúãÂà∞ÁöÑÂ•áÂ¶ôÊñπÊ≥ï123456def maxProduct(self, A): B = A[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B) 942.DI String Match123456789101112131415161718def diStringMatch(self, S): &quot;&quot;&quot; :type S: str :rtype: List[int] &quot;&quot;&quot; i = 0 j = len(S) res = [] for x in S: if x==&apos;I&apos;: res.append(i) i+=1 else: res.append(j) j-=1 res.append(j if S[-1]==&apos;D&apos; else i) return res]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂçÅÔºâ]]></title>
    <url>%2F2018%2F08%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩï(ÂçÅ)ÂºÄÂßãÊåâÈ°∫Â∫èÂà∑‰∫ÜÔºàhardËøòÊòØÈöèÁºòÂêßÔºâÔΩûËØ≠Ë®ÄÁè≠‰πüÂºÄËØæ‰∫ÜÔºå‰∫ãÊÉÖÂ§ö‰∫ÜËµ∑Êù•‰∫ÜÔºåÂ∏åÊúõÊúâ‰∏Ä‰∏™Ê∞∏Êó†Ê≠¢Â¢ÉÁöÑÂÖ´Êúà 1. Two SumÂú®python‰∏≠ÔºåÂØªÊâæÂÖÉÁ¥†Âú®dictionary‰∏≠ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(1),Âú®list‰∏≠‰∏∫O(n)123456789n = len(nums) if n&lt;=1: return False dic = &#123;&#125; for i in range(n): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 2. Add Two Numbers12345678910ret = cur = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val/10 cur.next = ListNode(val%10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next 3. Longest Substring Without Repeating CharactersÊâæÊúÄÈïø‰∏çÈáçÂ§çÂ≠ê‰∏≤ÔºåËßâÂæóËøô‰∏™ÊÄùÊÉ≥‰ª•ÂêéËøò‰ºöÁî®Âà∞123456789start = maxL = 0 usedCh = &#123;&#125; for i in range(len(s)): if s[i] in usedCh and start &lt;= usedCh[s[i]]: start = usedCh[s[i]] + 1 else: maxL = max(maxL,i-start+1) usedCh[s[i]] = i return maxL 5. Longest Palindromic SubstringÊâæÊúÄÈïøÂõûÊñáÂ≠ê‰∏≤Ôºå‰ºº‰πéÂÅöËøáÁ¨¨‰∏ÄÁßçÂäûÊ≥ïÁõ¥Êé•Ëß£ÔºåÊö¥Âäõüê∏123456789101112131415161718192021class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = &quot;&quot; for i in xrange(len(s)): tmp = self.helper(s,i,i) if len(tmp) &gt;len(res): res = tmp tmp = self.helper(s,i,i+1) if len(tmp) &gt;len(res): res = tmp return res def helper(self,s,l,r): while l&gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1 r+=1 return s[l+1:r] Á¨¨‰∫åÁßçÂ≠¶‰π†‰∏Ä‰∏ãManacherÁÆóÊ≥ïÔºöÂú®Â≠óÁ¨¶‰∏≤È¶ñÂ∞æ‰ª•ÂèäÂêÑ‰∏™Â≠óÁ¨¶Èó¥ÊèíÂÖ•‰∏Ä‰∏™Â≠óÁ¨¶ÔºåÂÆö‰πâËæÖÂä©Êï∞ÁªÑp[]Ë°®Á§∫‰ª•i‰∏∫‰∏≠ÂøÉÁöÑÊúÄÈïøÂõûÊñáÁöÑÂçäÂæÑÔºåÂàôp[i]-1Â∞±ÊòØÂéüÂ≠óÁ¨¶‰∏≤‰∏≠ÊúÄÈïøÂõûÊñáÁöÑÈïøÂ∫¶„ÄÇp[]ÁöÑÊ±ÇËß£ÔºöËÆæÁΩÆ‰∏§‰∏™ÂèòÈáèÔºåmx Âíå id „ÄÇmx ‰ª£Ë°®‰ª• id ‰∏∫‰∏≠ÂøÉÁöÑÊúÄÈïøÂõûÊñáÁöÑÂè≥ËæπÁïåÔºå‰πüÂ∞±ÊòØmx = id + p[id]„ÄÇÂàôp[i] = min(p[2 * id - i], mx - i)12345678910111213141516def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; T = &apos;#&apos;.join(&apos;^&#123;&#125;$&apos;.format(s)) n = len(T) p = [0]*n c = r= 0 for i in range(1,n-1): while T[i+1+p[i]] == T[i-1-p[i]]: p[i]+=1 if i + p[i] &gt;r: c,r=i,i+p[i] maxLen, centerIndex = max((n, i) for i, n in enumerate(p)) return s[(centerIndex - maxLen)//2: (centerIndex + maxLen)//2] 6. ZigZag Conversion12345678910111213if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index,step = 0,1 for x in s: L[index] += x if index == 0: step =1 elif index == numRows - 1: step = -1 index +=step return &apos;&apos;.join(L) 7. Reverse IntegerË¶ÅËÄÉËôëÂà∞ËæπÁïåÊÉÖÂÜµ123s = (x&gt;0) - (x&lt;0) r = int(str(x*s)[::-1]) return s*r*(r&lt;2**31) ‰∏çÁî®strÁöÑÊñπÊ≥ï1234567891011i,res,sign = 0,0,1 if x&lt;0: sign = -1 x = abs(x) while x!=0: res=res*10+(x%10) x/=10 if res&lt;-2147483648 or res&gt;2147483648: return 0 else: return res*sign 9.Palindrome NumberÂà§Êñ≠Êï∞Â≠óÊòØÂê¶ÊòØÂõûÊñá1234567if x&lt;0: return False p,res = x,0 while p: res = res*10 +p%10 p /= 10 return res == x 14. Longest Common Prefix1234567891011121314s = len(strs) if s == 0: return &apos;&apos; lens = [len(str) for str in strs] min_len = min(lens) result = &apos;&apos; for i in range(1,min_len+1): pre = strs[0][:i] for s in strs: if s[:i] != pre: return result result = pre return result ÁúüÁöÑÂ•ΩÂøôÂïä‚Ä¶‚Ä¶]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰πùÔºâ]]></title>
    <url>%2F2018%2F07%2F18%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩï(‰πù)Âú®Â§©ÂõΩÁöÑÂä®ÊÄÅËßÑÂàí Fizz Buzz1return [str(i)*(i%5!=0 and i%3!=0) + &apos;Fizz&apos;*(i%3 == 0) + &apos;Buzz&apos;*(i%5 ==0) for i in range(1,n+1)] Single Number123456dic =&#123;&#125;for num in nums: dic[num] = dic.get(num,0) +1for key, value in dic.items(): if value == 1: return key Âè¶Â§ñËøòÊúâ‰∏ÄÁßçÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫o(n)ÁöÑÊñπÊ≥ïÔºö1return reduce(lambda x,y:x^y, nums) reduce()ÂáΩÊï∞Â∞Ü‰∏Ä‰∏™Êï∞ÊçÆÈõÜÂêàÔºàÈìæË°®ÔºåÂÖÉÁªÑÁ≠âÔºâ‰∏≠ÁöÑÊâÄÊúâÊï∞ÊçÆËøõË°å‰∏ãÂàóÊìç‰ΩúÔºöÁî®‰º†Áªô reduce ‰∏≠ÁöÑÂáΩÊï∞ functionÔºàÊúâ‰∏§‰∏™ÂèÇÊï∞ÔºâÂÖàÂØπÈõÜÂêà‰∏≠ÁöÑÁ¨¨ 1„ÄÅ2 ‰∏™ÂÖÉÁ¥†ËøõË°åÊìç‰ΩúÔºåÂæóÂà∞ÁöÑÁªìÊûúÂÜç‰∏éÁ¨¨‰∏â‰∏™Êï∞ÊçÆÁî® function ÂáΩÊï∞ËøêÁÆóÔºåÊúÄÂêéÂæóÂà∞‰∏Ä‰∏™ÁªìÊûú Product of Array Except Self1234567891011output=[] p = 1 n = len(nums) for i in range(0,n): output.append(p) p = p*nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i]*p p = p*nums[i] return output Sum of Two Integers123456MAX = 0x7FFFFFFF MIN = 0x80000000 mask = 0xFFFFFFFF while b!=0: a,b = (a^b)&amp;mask,((a&amp;b)&lt;&lt;1)&amp;mask return a if a&lt;=MAX else ~(a^mask) Top K Frequent ElementsÈ°∫‰æøÂ≠¶‰π†heapqÊ®°ÂùóÁöÑ‰ΩøÁî®„ÄÇ item = heapreplace(heap,item) ÂºπÂá∫Âπ∂ËøîÂõûÊúÄÂ∞èÂÄº nlargest(n , iterbale, key=None) ‰ªéÂ†Ü‰∏≠ÊâæÂá∫ÂÅöÂ§ßÁöÑN‰∏™Êï∞ÔºåkeyÁöÑ‰ΩúÁî®Âíåsorted( )ÊñπÊ≥ïÈáåÈù¢ÁöÑkeyÁ±ª‰ººÔºåÁî®ÂàóË°®ÂÖÉÁ¥†ÁöÑÊüê‰∏™Â±ûÊÄßÂíåÂáΩÊï∞‰Ωú‰∏∫ÂÖ≥ÈîÆÂ≠ó„ÄÇ nsmallest(n, iterable, key=None) ÊâæÂà∞Â†Ü‰∏≠ÊúÄÂ∞èÁöÑN‰∏™Êï∞„ÄÇ heappushpop() Â∞ÜÂÄºÊèíÂÖ•Âà∞Â†Ü‰∏≠ÂêåÊó∂ÂºπÂá∫Â†Ü‰∏≠ÁöÑÊúÄÂ∞èÂÄº„ÄÇ merge(*iterables) ÂêàÂπ∂Â§ö‰∏™Â†ÜÁÑ∂ÂêéËæìÂá∫12345from collections import Counter import heapq - [ ] c = Counter(nums) return heapq.nlargest(k,c,c.get) Excel Sheet Column Number12345n=len(s) num=0 for i,x in enumerate(s): num+=(ord(x)-64)*26**(n-i-1) return num ËøòÂèØ‰ª•Áî®reduceÂÅö=„ÄÇ= Majority Element12345678910 return sorted(nums)[len(nums)//2]//Âè¶‰∏ÄÁßçÂäûÊ≥ïpool = [] n = len(nums) for i in range(n): if nums[i] not in pool: if nums.count(nums[i]) &gt; n/2: return nums[i] pool.append(nums[i]) Binary Tree Inorder TraversalÈÄíÂΩíÊå∫ÁÆÄÂçïÁöÑÔºåÊâÄ‰ª•Âè™ÂÅö‰∫ÜËø≠‰ª£1234567891011stack=[] output=[] while True: while root: stack.append(root) root = root.left if not stack: return output node = stack.pop() output.append(node.val) root = node.right Best Time to Buy and Sell Stock1234567if not prices: return 0 max_profit = sell_price = 0 for price in prices[::-1]: sell_price = max(sell_price, price) max_profit = max(max_profit,sell_price - price) return max_profit Best Time to Buy and Sell Stock IIÊÉä‰∫ÜËøôÈÅìÈ¢òÊàëËøòÊÉ≥‰∫ÜÂ•Ω‰πÖÔºåÂéüÊù•Ëøô‰πàÁÆÄÂçïorz1return sum(max(prices[i+1]-prices[i],0) for i in range(len(prices)-1)) Permutations1234567891011121314if not nums: return None stack = [[[nums[0]],0]] i,res = 0, [] while(stack): arr, index = stack.pop() if index == len(nums)-1: res.append(arr) else: for i in range(len(arr)+1): newPermutation = arr[:i]+[nums[index+1]]+arr[i:] stack.append([newPermutation,index+1]) return res First Unique Character in a String123letters=&apos;abcdefghijklmnopqrstuvwxyz&apos; index = [s.index(l) for l in letters if s.count(l) == 1] return min(index) if len(index) &gt; 0 else -1 Generate Parentheses‰πüÊòØÂÖ®ÊéíÂàóÈóÆÈ¢ò1234567891011res = [] def dfs(l,r,path,res): if r &lt; l or l == -1 or r == -1: return if l == 0 and r == 0: res.append(path[:]) else: dfs(l-1, r, path + &quot;(&quot;, res) dfs(l, r-1, path + &quot;)&quot;, res) dfs(n,n,&quot;&quot;,res) return(res) Missing Number12n = len(nums) return n*(n+1)/2 - sum(nums)]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂÖ´Ôºâ]]></title>
    <url>%2F2018%2F05%2F30%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂÖ´Ôºâ349. Intersection of Two Arrays123456789 def intersection(self, nums1, nums2): ‚Äú‚Äù‚Äù :type nums1: List[int] :type nums2: List[int] :rtype: List[int] ‚Äú‚Äù‚Äù n1 = set(nums1) n2 = set(nums2) return list(n1&amp;n2) Valid Anagram12345678910111213141516def isAnagram(self, s, t): ‚Äú‚Äù‚Äù :type s: str :type t: str :rtype: bool ‚Äú‚Äù‚Äù if len(s) != len(t): return False count = collections.defaultdict(int) for c in s: count[c] += 1 for c in t: count[c] -= 1 if count[c] &lt; 0: return False return True defaultdict Â∞±ÊòØ‰∏Ä‰∏™Â≠óÂÖ∏ÔºåÂè™‰∏çËøápythonËá™Âä®ÁöÑ‰∏∫ÂÆÉÁöÑÈîÆËµã‰∫Ü‰∏Ä‰∏™ÂàùÂßãÂÄº„ÄÇËøô‰πüÂ∞±ÊòØËØ¥Ôºå‰Ω†‰∏çÊòæÁ§∫ÁöÑ‰∏∫Â≠óÂÖ∏ÁöÑÈîÆËµãÂàùÂÄºpython‰∏ç‰ºöÊä•Èîô 350. Intersection of Two Arrays II12345678def intersect(self, nums1, nums2): ‚Äú‚Äù‚Äù :type nums1: List[int] :type nums2: List[int] :rtype: List[int] ‚Äú‚Äù‚Äù a,b = map(collections.Counter,(nums1,nums2)) return list((a&amp;b).elements()) 496. Next Greater Element I123456789101112def nextGreaterElement(self, findNums, nums): ‚Äú‚Äù‚Äù :type findNums: List[int] :type nums: List[int] :rtype: List[int] ‚Äú‚Äù‚Äù greater,stack = &#123;&#125;,[] for n in nums: while stack and n &gt; stack[-1]: greater[stack.pop()] = n stack.append(n) return [greater[n] if n in greater else -1 for n in findNums] 693. Binary Number with Alternating Bits12s = bin(n) return ‚Äô00‚Äô not in s and ‚Äô11‚Äô not in s 553. Optimal Division12345678910 def optimalDivision(self, nums): ‚Äú‚Äù‚Äù :type nums: List[int] :rtype: str ‚Äú‚Äù‚Äù nums = list(map(str, nums)) if len(nums) &gt; 2: nums[1] = ‚Äú(‚Äú +nums[1] nums[-1] = nums[-1] + ‚Äú)‚Äù return ‚Äú/‚Äú.join(nums) ËøôÈáåÊòØÊØîËæÉtrickyÁöÑÔºåÊúÄÂ§ßÁöÑÈô§Ê≥ï‰∏ÄÂÆöÊòØX1/(X2..Xn) 647. Palindromic Substrings1234567891011def countSubstrings(self, s): ‚Äú‚Äù‚Äù :type s: str :rtype: int ‚Äú‚Äù‚Äù res = 0 for j in range(len(s) + 1): for i in range(j): if s[i:j] == s[i:j][::-1]: res +=1 return res 226. Invert Binary Tree123456789101112def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack += node.left, node.right return root ```ÈÄíÂΩíÊñπÊ≥ïËøòÊòØÊØîËæÉÁÆÄÂçïÁöÑÔºåÊâÄ‰ª•Âè™ÂÜôËø≠‰ª£]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á•ûÁªèÁΩëÁªúÂ≠¶‰π†note2]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0note2%2F</url>
    <content type="text"><![CDATA[Á•ûÁªèÁΩëÁªúÂ≠¶‰π†note2note1ÂíåÂä®ÊÄÅËßÑÂàíÈÉΩË¢´ÊàëÂêÉÊéâ‰∫Ü ‰∏Ä‰∫õÂü∫Á°ÄÁü•ËØÜÂØπ‰∏ÄËà¨ÁöÑÁõëÁù£ÂºèÂ≠¶‰π†Ôºå‰ΩøÁî®Ê†áÂáÜÁöÑÁ•ûÁªèÁΩëÁªúÊ®°ÂûãÂØπÂõæÂÉèËØÜÂà´Â§ÑÁêÜÈóÆÈ¢òÔºå‰ΩøÁî®Âç∑ÁßØÁ•ûÁªèÁΩëÁªúÔºàCNNÔºâÂØπÁ±ª‰ººËØ≠Èü≥ÁöÑÂ∫èÂàó‰ø°Âè∑Ôºå‰ΩøÁî®Âæ™ÁéØÁ•ûÁªèÁΩëÁªúÔºàRNNÔºâ Structured Data: ÊúâÂÆûÈôÖÊÑè‰πâÁöÑÊï∞ÊçÆUnstructured DataÔºöÊØîËæÉÊäΩË±°ÁöÑÊï∞ÊçÆ ‰∫åÂàÜÁ±ªÈÄªËæëÂõûÂΩíÔºàLogisitic RegressionÔºâ‰∏ÄËà¨Áî®Êù•Ëß£ÂÜ≥‰∫åÂàÜÁ±ªÔºàBinary ClassificationÔºâÈóÆÈ¢òÈÄªËæëÂõûÂΩíÁöÑÈ¢ÑÊµãËæìÂá∫ÂèØ‰ª•ÂÜôÊàêÔºösigmoidÂáΩÊï∞ÁöÑÊÑè‰πâÂú®‰∫éÂ∞ÜÈÄªËæëÂõûÂΩíÁöÑËæìÂá∫ÈôêÂÆöÂú®[0,1]Èó¥ ÊçüÂ§±ÂáΩÊï∞Ôºàcost functionÔºâÔºöÈÄâÊã©ÁöÑÊçüÂ§±ÂáΩÊï∞‰∏ÄËà¨Â∫îËØ•ÊòØconvexÁöÑÊ¢ØÂ∫¶‰∏ãÈôçÔºö‰ΩøÁî®Ê¢ØÂ∫¶‰∏ãÈôçÊù•ËÆ°ÁÆóÂá∫ÂêàÈÄÇÁöÑwÔºåbÂÄºÔºåÊúÄÂ∞èÂåñÊçüÂ§±ÂáΩÊï∞ PythonÊú∫Âà∂ÂêëÈáèÂåñÔºàVectorizationÔºâ Âú®python‰∏≠‰ΩøÁî®ÂêëÈáèÂåñË¶ÅÊØî‰ΩøÁî®Âæ™ÁéØËÆ°ÁÆóÈÄüÂ∫¶Âø´ÂØπ‰∫éÊâÄÊúâm‰∏™Ê†∑Êú¨ÔºådZ„ÄÅdb„ÄÅdwÂèØË°®Á§∫‰∏∫ÔºöZ = np.dot(w.T,X) +bA = sigmoid(Z)dZ = A - Ydw = 1/mnp.dot(X,dZ.T)db = 1/mnp.sum(dZ) w = w - alphadwb = b - alphadb python‰∏≠ÁöÑÂπøÊí≠Êú∫Âà∂Ôºö ËÆ©ÊâÄÊúâËæìÂÖ•Êï∞ÁªÑÈÉΩÂêëÂÖ∂‰∏≠shapeÊúÄÈïøÁöÑÊï∞ÁªÑÁúãÈΩêÔºåshape‰∏≠‰∏çË∂≥ÁöÑÈÉ®ÂàÜÈÉΩÈÄöËøáÂú®ÂâçÈù¢Âä†1Ë°•ÈΩê ËæìÂá∫Êï∞ÁªÑÁöÑshapeÊòØËæìÂÖ•Êï∞ÁªÑshapeÁöÑÂêÑ‰∏™ËΩ¥‰∏äÁöÑÊúÄÂ§ßÂÄº Â¶ÇÊûúËæìÂÖ•Êï∞ÁªÑÁöÑÊüê‰∏™ËΩ¥ÂíåËæìÂá∫Êï∞ÁªÑÁöÑÂØπÂ∫îËΩ¥ÁöÑÈïøÂ∫¶Áõ∏ÂêåÊàñËÄÖÂÖ∂ÈïøÂ∫¶‰∏∫1Êó∂ÔºåËøô‰∏™Êï∞ÁªÑËÉΩÂ§üÁî®Êù•ËÆ°ÁÆóÔºåÂê¶ÂàôÂá∫Èîô ÂΩìËæìÂÖ•Êï∞ÁªÑÁöÑÊüê‰∏™ËΩ¥ÁöÑÈïøÂ∫¶‰∏∫1Êó∂ÔºåÊ≤øÁùÄÊ≠§ËΩ¥ËøêÁÆóÊó∂ÈÉΩÁî®Ê≠§ËΩ¥‰∏äÁöÑÁ¨¨‰∏ÄÁªÑÂÄº Á•ûÁªèÁΩëÁªúÁöÑÊ≠£Âêë‰º†Êí≠ÔºöËæìÂÖ•Â±ÇÂà∞ÈöêËóèÂ±ÇÔºå‰∏ÄÊ¨°ÈÄªËæëÂõûÂΩíËøêÁÆóÈöêËóèÂ±ÇÂà∞ËæìÂá∫Â±ÇÔºå‰∏ÄÊ¨°ÈÄªËæëÂõûÂΩíËøêÁÆó Ë°åË°®Á§∫Á•ûÁªèÂÖÉ‰∏™Êï∞ÔºåÂàóË°®Á§∫Ê†∑Êú¨Êï∞ÁõÆm ÊøÄÊ¥ªÂáΩÊï∞Ôºàactivation functionÔºâÂØπ‰∫éÈöêËóèÂ±ÇÔºå‰ΩøÁî®tanhÂáΩÊï∞ËæÉÂ•ΩÔºåÈöêËóèÂ±ÇÁöÑËæìÂá∫Ë¢´ÈôêÂÆöÂú®[-1,1]Èó¥ÔºåÂú®0ÂÄºÈôÑËøëÂàÜÂ∏ÉÔºåÂùáÂÄº‰∏∫0ÔºåËøôÊ†∑‰ªéÈöêËóèÂ±ÇÂà∞ËæìÂá∫Â±ÇÔºåÊï∞ÊçÆËµ∑Âà∞‰∫ÜÂΩí‰∏ÄÂåñÁöÑÊïàÊûú„ÄÇÂΩì|z|ÂæàÂ§ßÊó∂ÔºåsigmoidÂíåtanhÂáΩÊï∞ÁöÑÊñúÁéáÈÉΩÂæàÂ∞èÔºåÊ¢ØÂ∫¶‰∏ãÈôçÁÆóÊ≥ïÁöÑÈÄüÂ∫¶‰ºöÂèòÊÖ¢ÔºåÊâÄ‰ª•Âá∫Áé∞‰∫ÜReLuÂáΩÊï∞„ÄÇ ÂèçÂêë‰º†Êí≠Ôºöw[1]Âíåw[2]ÈÉΩ‰∏çËÉΩÂàùÂßãÂåñ‰∏∫Èõ∂ÔºåËã•ÂàùÂßãÂåñ‰∏∫Èõ∂Ëø≠‰ª£Êõ¥Êñ∞‰ºöÂæóÂà∞ÂêåÊ†∑ÁöÑÁªìÊûú Ê∑±Â±ÇÁ•ûÁªèÁΩëÁªúÂ∞±ÊòØÂåÖÂê´Êõ¥Â§öÈöêËóèÂ±ÇÁöÑÁ•ûÁªèÁΩëÁªúÂØπ‰∫éÁ¨¨lÂ±ÇÔºåÊ≠£Âêë‰º†Êí≠ËøáÁ®ãÂèØ‰ª•Ë°®Á§∫‰∏∫ÔºöÁª¥Â∫¶ÂàÜÂà´‰∏∫Ôºö]]></content>
      <categories>
        <category>ngËØæÁ®ãÁ¨îËÆ∞</category>
      </categories>
      <tags>
        <tag>NN</tag>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∏ÉÔºâ]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∏ÉÔºâÊòéÂ§©ÈáçÁÇπÁúãÁúãÂä®ÊÄÅËßÑÂàíÈóÆÈ¢ò 543. Diameter of Binary Tree123456789101112131415def diameterOfBinaryTree(self, root): ‚Äú‚Äù‚Äù :type root: TreeNode :rtype: int ‚Äú‚Äù‚Äù self.ans = 0 def depth(node): if not node: return 0 anL, anR = depth(node.right), depth(node.left) self.ans = max(self.ans, anL+anR) return 1+max(anL, anR) depth(root) return self.ans 540. Single Element in a Sorted Array12345678910111213def singleNonDuplicate(self, nums): ‚Äú‚Äù‚Äù :type nums: List[int] :rtype: int ‚Äú‚Äù‚Äù left, right = 0, len(nums)-1 while left &lt; right: mid = (left + right)/2 if nums[mid] == nums[mid+1]: right = mid + 1 else: left = mid return nums[left] ÁÑ∂ÈπÖË∂ÖÊó∂‰∫Ü‚Ä¶‚Ä¶‰∏çËøáÂÖàËøôÊ†∑ÂÜôÁùÄÂêß 198. House Robber12345678910 def rob(self, nums): ‚Äú‚Äù‚Äù :type nums: List[int] :rtype: int ‚Äú‚Äù‚Äù i, j = 0, 0 for m in nums: k, i = i, m + j j = max(k, j) return max(i, j) f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 104. Maximum Depth of Binary Tree12345678def maxDepth(self, root): ‚Äú‚Äù‚Äù :type root: TreeNode :rtype: int ‚Äú‚Äù‚Äù if not root: return 0 return 1+max(self.maxDepth(root.left), self.maxDepth(root.right))]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂÖ≠Ôºâ]]></title>
    <url>%2F2018%2F05%2F16%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂÖ≠ÔºâÂ∫îËØ•ÊòØ‰∏äÂë®Âà∑ÁöÑÈ¢ò‰∏ÄÁõ¥ÂøòËÆ∞Âèë‰∫Ü 763. Partition Labels1234567891011121314class Solution(object): def partitionLabels(self, S): ‚Äú‚Äù‚Äù :type S: str :rtype: List[int] ‚Äú‚Äù‚Äù size = [] while S: I = 1 while set(S[I:])&amp;set(S[:I]): I+=1 size.append(i) S=S[I:] return size 806. Number of Lines To Write String123456789101112def numberOfLines(self, widths, S): ‚Äú‚Äù‚Äù :type widths: List[int] :type S: str :rtype: List[int] ‚Äú‚Äù‚Äù res, cur = 1, 0 for I in S: width = widths[ord(i) - ord(‚Äòa‚Äô)] res += 1 if cur + width &gt; 100 else 0 cur = width if cur +width &gt; 100 else cur + width return [res, cur] 537. Complex Number Multiplication12345678def complexNumberMultiply(self, a, b): ‚Äú‚Äù‚Äù :type a: str :type b: str :rtype: str ‚Äú‚Äù‚Äù a, ai, b, bi = map(int, re.findall(‚Äò-?\d+‚Äô, a+b)) return ‚Äò%d+%di‚Äô % (a*b - ai*bi, a*bi + ai*b) 419. Battleships in a Board12345678910111213141516def countBattleships(self, board): ‚Äú‚Äù‚Äù :type board: List[List[str]] :rtype: int ‚Äú‚Äù‚Äù total = 0 for I in range(len(board)): for j in range(len(board[0])): if board[I][j] == ‚ÄòX‚Äô: flag = 1 if j&gt;0 and board[I][j-1] == ‚ÄòX‚Äô: flag = 0 if I&gt;0 and board[i-1][j] == ‚ÄòX‚Äô: flag = 0 total += flag return total 821. Shortest Distance to a Character1234567### def shortestToChar(self, S, C):### ‚Äú‚Äù‚Äù### :type S: str### :type C: str### :rtype: List[int]### ‚Äú‚Äù‚Äù### return [min(abs(I - j) for j, e in enumerate(S) if e == C) for I in range(len(S))] 530.Minimum Absolute Difference in BST12345678910111213def getMinimumDifference(self, root): ‚Äú‚Äù‚Äù :type root: TreeNode :rtype: int ‚Äú‚Äù‚Äù def dsf(node, l = []): if node.left: dsf(node.left, l) l.append(node.val) if node.right: dsf(node.right, l) return l l = [1,2,3,4,5] return zip(l,l[1:]) 669. Trim a Binary Search Tree12345678910111213141516 def trimBST(self, root, L, R): ‚Äú‚Äù‚Äù :type root: TreeNode :type L: int :type R: int :rtype: TreeNode ‚Äú‚Äù‚Äù if not root: return None if L &gt; root.val: return self.trimBST(root.right, L, R) elif R &lt; root.val: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root 513. Find Bottom Left Tree Value123456789def findBottomLeftValue(self, root): ‚Äú‚Äù‚Äù :type root: TreeNode :rtype: int ‚Äú‚Äù‚Äù q = [root] for node in q: q+=filter(None, (node.right, node.left)) return q 637. Average of Levels in Binary Tree12345678910def dfs(node, depth = 0): if node: if len(info) &lt;= depth: info.append([0,0]) info[depth][0] += node.val info[depth][1] += 1 dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root) return [s/float(c) for s,c in info]]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∫îÔºâ]]></title>
    <url>%2F2018%2F05%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∫îÔºâÂôó 797. All Paths From Source to Target12345678def allPathsSourceTarget(self, graph): def dfs(cur, path): if cur == len(graph) - 1: res.append(path) else: for i in graph[cur]: dfs(i, path + [i]) res = [] dfs(0, [0]) return res 617.Merge Two Binary TreesGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.12345678910111213def mergeTrees(self, t1, t2): &quot;&quot;&quot; :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode &quot;&quot;&quot; if t1 and t2: root = TreeNode(t1.val+t2.val) root.left = self.mergeTrees(t1.left,t2.left) root.right = self.mergeTrees(t1.right,t2.right) return root else: return t1 or t2 728.Self Dividing Numbers12is_self_dividing = lambda num: &apos;0&apos; not in str(num) and all(num % int(digit) == 0 for digit in str(num)) return filter(is_self_dividing, range(left, right + 1)) Subdomain Visit Count123456789101112131415161718def subdomainVisits(self, cpdomains): &quot;&quot;&quot; :type cpdomains: List[str] :rtype: List[str] &quot;&quot;&quot; visits, res = &#123;&#125;, [] for domain in cpdomains: tmp = domain.split() count, doms = int(tmp[0]), tmp[1].split(&apos;.&apos;) for i in range(len(doms)): domain = &apos;.&apos;.join(doms[i:]) if visits.get(domain, 0): visits[domain] += count else: visits[domain] = count for v in visits.items(): res.append(str(v[1]) + &apos; &apos; + v[0]) return res 814.Binary Tree Pruning123456789class Solution: def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root root.left, root.right = self.pruneTree(root.left), self.pruneTree(root.right) return root if root.val == 1 or root.left or root.right else None Ë¶ÅËÆ§ÁúüÂ≠¶‰π†ÂïäÔºÅÊ≤°Êúâ‰π∞Âà∞‰ºòË°£Â∫ìÁöÑTÊÅ§qwq]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂõõÔºâ]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºàÂõõÔºâÈìæË°® 237.Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.12345678class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 725.Split Linked List in Parts1234567891011121314151617181920def splitListToParts(self, root, k): &quot;&quot;&quot; :type root: ListNode :type k: int :rtype: List[ListNode] &quot;&quot;&quot; curr, length = root, 0 while curr: curr, length = curr.next, length + 1 chunk, longer = length//k, length%k res = [chunk + 1]*longer + [chunk]*(k-longer) prev, curr = None, root for index, num in enumerate(res): if prev: prev.next = None res[index] = curr for i in range(num): prev, curr = curr, curr.next return res ÂàÜ‰∏âÊ≠•ÔºöÊ±ÇÈïøÂ∫¶ÔºåÂàáÂùóÔºåÊääÊï∞ÊçÆË£ÖËøõÂéª 206.Reverse Linked ListËø≠‰ª£‰∏çÂ§™ÊáÇid‚Ä¶‚Ä¶12345678def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev ÈÄíÂΩí123456789def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 445.Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.123456789101112131415161718192021222324def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if not l1: return l2 if not l2: return l1 x1 = x2 = &apos;&apos; while l1: x1 += str(l1.val) l1 = l1.next while l2: x2 += str(l2.val) l2 = l2.next y = int(x1)+int(x2) y = str(y) head = next_node = ListNode(y[0]) for i in range(1, len(y)): next_node.next = ListNode(y[i]) next_node = next_node.next return head 328.Odd Even Linked List1234567891011121314151617def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; d1=odd=ListNode(0) d2=even=ListNode(0) i=1 while head: if i%2: odd.next,odd=head,head else: even.next,even=head,head head=head.next i+=1 odd.next,even.next=d2.next,None return d1.next Êîæ‰∫î‰∏Ä‰∫ÜÂï¶Âï¶Âï¶]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∏âÔºâ]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∏âÔºâ‰ªäÂ§©Èô§‰∫ÜÊï∞ÁªÑÈÉ®ÂàÜÔºåÂÜçÂÜô‰∏ÄÁÇπÈìæË°®Âêß( ÃÄ‚åÑ ÃÅ) 695.Max Area of IslandGiven a non-empty 2D array grid of 0‚Äôs and 1‚Äôs, an island is a group of 1‚Äôs (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.1234567891011def maxAreaOfIsland(self, grid): m, n = len(grid), len(grid[0]) def dfs(i, j): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j]: grid[i][j] = 0 return 1 + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i + 1, j) + dfs(i, j - 1) return 0 areas = [dfs(i, j) for i in range(m) for j in range(n) if grid[i][j]] return max(areas) if areas else 0 283.Move ZeroesGiven an array nums, write a function to move all 0‚Äôs to the end of it while maintaining the relative order of the non-zero elements.12345678def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for i in range(nums.count(0)): nums.remove(0) nums.append(0) Âè¶‰∏ÄÁßçÊñπÊ≥ïÔºö123456def moveZeroes(self, nums): zero = 0 # records the position of &quot;0&quot; for i in xrange(len(nums)): if nums[i] != 0: nums[i], nums[zero] = nums[zero], nums[i] zero += 1 667.Beautiful Arrangement IIÁÆÄÂçïÊù•ËØ¥Â∞±ÊòØÁªô[n,k], ÁîüÊàê‰∏Ä‰∏™listÔºåÂÖ∂‰∏≠Êúân‰∏™Ê≠£Êï¥Êï∞ÔºåÊ≠£Êï¥Êï∞Áõ∏ÂáèÂêéÁöÑÁªùÂØπÂÄºÁöÑÁªìÊûúÊúâk‰∏™Ê≠£Êï¥Êï∞„ÄÇ1234567891011121314a = [1]h = k+1l = 2for _k in range(k,0,-2): if _k == 1: a.append(h) break else: a.append(h) a.append(l) h -= 1 l += 1a.extend(range(k+2,n+1))return a 495.Teemo Attacking12345678910def findPoisonedDuration(self, tS, d): &quot;&quot;&quot; :type timeSeries: List[int] :type duration: int :rtype: int &quot;&quot;&quot; ans = len(tS)*d for i in range(1, len(tS)): ans -= max(0, d-tS[i]+tS[i-1]) return ans 448. Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ‚â§ a[i] ‚â§ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.12def findDisappearedNumbers(self, nums): return list(set([i for i in range(1,len(nums)+1)]).difference(set(nums))) Âè¶Â§ñ‰∏ÄÁßçÊ†áËÆ∞ÁöÑÊñπÊ≥ïÔºö12345for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] &gt; 0] Êå∫Êú∫Êô∫ÁöÑ‚Ä¶‚Ä¶ 817.Linked List Components12345678910111213def numComponents(self, head, G): &quot;&quot;&quot; :type head: ListNode :type G: List[int] :rtype: int &quot;&quot;&quot; setG = set(G) res = 0 while head: if head.val in setG and (head.next == None or head.next.val not in setG): res += 1 head = head.next return res ‰∏çËÉΩÊ≤âËø∑Â°ûÂ∞îËææÔºåË¶ÅÂ≠¶‰π†]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊúÄËøëÁúãÁöÑÂå∫ÂùóÈìæÁü•ËØÜÁöÑÂ∞èËÆ∞ÂΩï]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[1.Âå∫ÂùóÈìæÁöÑÂÆö‰πâÂå∫ÂùóÈìæÊòØ‰ª•ÊØîÁâπÂ∏Å‰∏∫‰ª£Ë°®ÁöÑÊï∞Â≠óÂä†ÂØÜË¥ßÂ∏Å‰ΩìÁ≥ª ÁöÑÊ†∏ÂøÉÊîØÊíëÊäÄÊúØ. Âå∫ÂùóÈìæÊäÄÊúØÁöÑÊ†∏ÂøÉ‰ºòÂäøÊòØÂéª‰∏≠ÂøÉÂåñ, ËÉΩÂ§üÈÄöËøáËøêÁî®Êï∞ÊçÆÂä†ÂØÜ„ÄÅÊó∂Èó¥Êà≥„ÄÅÂàÜÂ∏ÉÂºèÂÖ±ËØÜÂíåÁªèÊµéÊøÄÂä±Á≠âÊâãÊÆµ, Âú®ËäÇÁÇπÊó†ÈúÄ‰∫íÁõ∏‰ø°‰ªªÁöÑÂàÜÂ∏ÉÂºèÁ≥ªÁªü‰∏≠ÂÆûÁé∞Âü∫‰∫éÂéª‰∏≠ÂøÉÂåñ‰ø°Áî®ÁöÑÁÇπÂØπÁÇπ‰∫§Êòì„ÄÅÂçèË∞É‰∏éÂçè‰Ωú, ‰ªéËÄå‰∏∫Ëß£ÂÜ≥‰∏≠ÂøÉÂåñÊú∫ÊûÑÊôÆÈÅçÂ≠òÂú®ÁöÑÈ´òÊàêÊú¨„ÄÅ‰ΩéÊïàÁéáÂíåÊï∞ÊçÆÂ≠òÂÇ®‰∏çÂÆâÂÖ®Á≠âÈóÆÈ¢òÊèê‰æõ‰∫ÜËß£ÂÜ≥ÊñπÊ°à„ÄÇÁâπÁÇπÔºöÂéª‰∏≠ÂøÉÂåñ„ÄÅÊó∂Â∫èÊï∞ÊçÆ„ÄÅÈõÜ‰ΩìÁª¥Êä§„ÄÅÂèØÁºñÁ®ãÂíåÂÆâÂÖ®ÂèØ‰ø° Âå∫ÂùóÈìæÁöÑÂü∫Á°ÄÊû∂ÊûÑÊ®°Âûã Êï∞ÊçÆÂ±ÇÔºöÂ∞ÅË£ÖÂ∫ïÂ±ÇÊï∞ÊçÆÂå∫Âùó‰ª•ÂèäÁõ∏ÂÖ≥ÁöÑÊï∞ÊçÆÂä†ÂØÜÂíåÊó∂Èó¥Êà≥Á≠âÊäÄÊúØ ÁΩëÁªúÂ±ÇÔºöÂåÖÊã¨ÂàÜÂ∏ÉÂºèÁªÑÁΩëÊú∫Âà∂„ÄÅÊï∞ÊçÆ‰º†Êí≠Êú∫Âà∂ÂíåÊï∞ÊçÆÈ™åËØÅÊú∫Âà∂Á≠â ÂÖ±ËØÜÂ±ÇÔºöÂ∞ÅË£ÖÁΩëÁªúËäÇÁÇπÁöÑÂêÑÁ±ªÂÖ±ËØÜÁÆóÊ≥ï ÊøÄÂä±Â±ÇÔºöÂ∞ÜÁªèÊµéÂõ†Á¥†ÈõÜÊàêÂà∞Âå∫ÂùóÈìæÊäÄÊúØ‰ΩìÁ≥ª‰∏≠Ôºå‰∏ªË¶ÅÂåÖÊã¨ÁªèÊµéÊøÄÂä±ÁöÑÂèëË°åÊú∫Âà∂ÂíåÂàÜÈÖçÊú∫Âà∂ ÂêàÁ∫¶Â±ÇÔºöÂ∞ÅË£ÖÂêÑÁ±ªËÑöÊú¨„ÄÅÁÆóÊ≥ïÂíåÊô∫ËÉΩÂêàÁ∫¶ Â∫îÁî®Â±ÇÔºöÂå∫ÂùóÈìæÁöÑÂêÑÁßçÂ∫îÁî®Âú∫ÊôØÂíåÊ°à‰æã ‰∏äÂõæ‰∏∫Êï∞ÊçÆÂå∫ÂùóÁöÑÁªìÊûÑÔºåÂàÜ‰∏∫Âå∫ÂùóÂ§¥ÂíåÂå∫Âùó‰Ωì‰∏§ÈÉ®ÂàÜ„ÄÇÊúÄÂÖàÊâæÂà∞Ê≠£Á°ÆÁöÑËß£ÈöèÊú∫Êï∞NonceÂπ∂ÁªèËøáÂÖ®‰ΩìÁüøÂ∑•È™åËØÅÁöÑÁüøÂ∑•‰ºöËé∑ÂæóÂΩìÂâçÂå∫ÂùóÁöÑËÆ∞Â∏êÊùÉÔºåËé∑ÂæóËÆ∞Â∏êÊùÉÁöÑÁüøÂ∑•Â∞ÜÂΩìÂâçÂå∫ÂùóÈìæÊé•Âà∞Ââç‰∏ÄÂå∫ÂùóÔºåÂΩ¢ÊàêÊúÄÊñ∞ÁöÑÂå∫Âùó‰∏ªÈìæ„ÄÇ 2.Âå∫ÂùóÈìæÁöÑÂàÜÁ±ªÂÖ¨ÂÖ±ÈìæÂÖ¨ÂÖ±ÈìæÂØπÂ§ñÂÖ¨ÂºÄÔºåÁî®Êà∑‰∏çÁî®Ê≥®ÂÜåÂ∞±ËÉΩÂåøÂêçÂèÇ‰∏éÔºåÊó†ÈúÄÊéàÊùÉÂç≥ÂèØËÆøÈóÆÁΩëÁªúÂíåÂå∫ÂùóÈìæÔºåÊòØÁúüÊ≠£ÊÑè‰πâ‰∏äÁöÑÂÆåÂÖ®Âéª‰∏≠ÂøÉÂåñÁöÑÂå∫ÂùóÈìæÔºåÂ¶ÇÊØîÁâπÂ∏ÅÂíå‰ª•Â§™Âùä ‰ª•Â§™Âùä‰ª•Â§™ÂùäÔºàEthereumÔºâÊòØ‰∏Ä‰∏™ÂºÄÊ∫êÁöÑÊúâÊô∫ËÉΩÂêàÁ∫¶ÂäüËÉΩÁöÑÂÖ¨ÂÖ±Âå∫ÂùóÈìæÂπ≥Âè∞„ÄÇÈÄöËøáÂÖ∂‰∏ìÁî®Âä†ÂØÜË¥ßÂ∏Å‰ª•Â§™Â∏ÅÔºàEtherÔºâÊèê‰æõÂéª‰∏≠ÂøÉÂåñÁöÑËôöÊãüÊú∫ÔºàÁß∞‰∏∫‚Äú‰ª•Â§™ËôöÊãüÊú∫‚ÄùEthereum Virtual MachineÔºâÊù•Â§ÑÁêÜÁÇπÂØπÁÇπÂêàÁ∫¶„ÄÇ‰ª•Â§™ÂùäÊòØ‰∏™Âπ≥Âè∞ÂíåÁºñÁ®ãËØ≠Ë®ÄÔºåÂåÖÊã¨Êï∞Â≠óË¥ßÂ∏ÅÂíåÁî®Êù•ÊûÑÂª∫ÂíåÂ∏ÜÂ∏ÉÂàÜÂ∏ÉÂºèÂ∫îÁî®ÁöÑ‰ª•Â§™ËÑöÊú¨ÔºåÊòØÂå∫ÂùóÈìæ‰∏éÊô∫ËÉΩÂêàÁ∫¶ÁöÑÂÆåÁæéÁªìÂêàÔºåÊã•Êúâ‰∏ÄÂ•óÂÆåÊï¥ÁöÑ„ÄÅÂèØ‰ª•Êâ©Â±ïÂÖ∂ÂäüËÉΩÁöÑÂ∑•ÂÖ∑ÔºåÂú®P2PÁΩëÁªú„ÄÅÂä†ÂØÜ„ÄÅHttpClientÁ≠âÊäÄÊúØÁöÑÊîØÊåÅ‰∏ãÂÆûÁé∞‰∫Ü‰∏Ä‰∏™Á±ª‰ºº‰∫éÊØîÁâπÂ∏ÅÁöÑÂå∫ÂùóÈìæ„ÄÇ ÁºñÁ®ãËØ≠Ë®ÄÔºöSolidity‰ª•Â§™ÂùäÂÖ∑Êúâ4Áßç‰∏ìÁî®ËØ≠Ë®ÄÔºöSerpentÔºàÈïøÂæóÂÉèPythonÔºâ„ÄÅSolidityÔºàJSÔºâ„ÄÅMutanÔºàGoÔºâÂíåLLLÔºàLispÔºâÊô∫ËÉΩÂêàÁ∫¶ÁöÑÈªòËÆ§ÁöÑÁºñÁ®ãËØ≠Ë®ÄÊòØSolidityÔºåÊñá‰ª∂Êâ©Â±ïÂêç‰ª•.solÁªìÂ∞æ„ÄÇSolidityÊòØÂíåJavaScriptÁõ∏‰ººÁöÑËØ≠Ë®ÄÔºåÁî®ÂÆÉÊù•ÂºÄÂèëÂêàÁ∫¶Âπ∂ÁºñËØëÊàê‰ª•Â§™ÂùäËôöÊãüÊú∫Â≠óËäÇ‰ª£Á†Å„ÄÇ ËøêË°åÁéØÂ¢ÉÔºöEVMEVMÔºàEthereum Virtual MachineÔºâ‰ª•Â§™ÂùäËôöÊãüÊú∫ÊòØ‰ª•Â§™Âùä‰∏≠Êô∫ËÉΩÂêàÁ∫¶ÁöÑËøêË°åÁéØÂ¢É„ÄÇEVMÊòØÁî±ËÆ∏Â§ö‰∫íÁõ∏ËøûÊé•ÁöÑËÆ°ÁÆóÊú∫ÁªÑÊàêÁöÑ„ÄÇ‰ªª‰Ωï‰∫∫ÈÉΩÂèØ‰ª•‰∏∫ÊâÄÊúâÊùÉ„ÄÅ‰∫§ÊòìÊ†ºÂºèÂíåÁä∂ÊÄÅËΩ¨ÂåñÂáΩÊï∞ÂàõÂª∫ÂïÜ‰∏öÈÄªËæë„ÄÇ ‰ª•Â§™ÂùäË¥¶Êà∑‰ª•Â§™ÂùäÂÜÖÊúâ‰∏§Á±ªË¥¶Êà∑„ÄÇÂ§ñÈÉ®Ë¥¶Êà∑Ë¢´ÂÖ¨Èí•-ÁßÅÈí•ÂØπÊéßÂà∂ÔºåÂêàÁ∫¶Ë¥¶Êà∑Ë¢´Â≠òÂÇ®Âú®Ë¥¶Êà∑‰∏≠ÁöÑ‰ª£Á†ÅÊéßÂà∂„ÄÇÂ§ñÈÉ®Ë¥¶Êà∑Ê≤°Êúâ‰ª£Á†ÅÔºå‰∫∫‰ª¨ÂèØ‰ª•ÈÄöËøáÂàõÂª∫ÂíåÁ≠æÂêç‰∏ÄÁ¨î‰∫§Êòì‰ªé‰∏Ä‰∏™Â§ñÈÉ®Ë¥¶Êà∑ÂèëÈÄÅÊ∂àÊÅØ„ÄÇÊØèÂΩìÂêàÁ∫¶Ë¥¶Êà∑Êî∂Âà∞‰∏ÄÊù°Ê∂àÊÅØÔºåÂêàÁ∫¶ÂÜÖÈÉ®ÁöÑ‰ª£Á†ÅÂ∞±‰ºöË¢´ÊøÄÊ¥ªÔºåÂÖÅËÆ∏ÂÆÉÂØπÂÜÖÈÉ®Â≠òÂÇ®ËøõË°åËØªÂèñÂÜôÂÖ•ÂèëÈÄÅÂÖ∂‰ªñÊ∂àÊÅØÂíåÂàõÂª∫ÂêàÁ∫¶„ÄÇ Gas‰ª•Â§™Âùä‰∏äÁöÑÊØèÁ¨î‰∫§ÊòìÈÉΩ‰ºöË¢´Êî∂Âèñ‰∏ÄÂÆöÊï∞ÈáèÁöÑÁáÉÊñôGasÔºåËÆæÁΩÆGasÁöÑÁõÆÁöÑÊòØÈôêÂà∂‰∫§ÊòìÊâßË°åÊâÄÈúÄÁöÑÂ∑•‰ΩúÈáèÔºåÂêåÊó∂‰∏∫‰∫§ÊòìÁöÑÊâßË°åÊîØ‰ªòË¥πÁî®„ÄÇ‰ªª‰ΩïÁâπÂÆöÁöÑÂêàÁ∫¶ÊâÄÈúÄÁöÑËøêË°åÂêàÁ∫¶ÁöÑGasÊï∞ÈáèÊòØÂõ∫ÂÆöÁöÑÔºåÁî±ÂêàÁ∫¶ÁöÑÂ§çÊùÇÂ∫¶ÂÜ≥ÂÆö„ÄÇËÄåGas‰ª∑Ê†ºÁî±ËøêË°åÂêàÁ∫¶ÁöÑ‰∫∫Âú®Êèê‰∫§ËøêË°åÂêàÁ∫¶ËØ∑Ê±ÇÁöÑÊó∂ÂÄôËßÑÂÆöÔºå‰ª•Á°ÆÂÆö‰ªñÊÑøÊÑè‰∏∫ËøôÊ¨°‰∫§ÊòìÊÑøÊÑè‰ªòÂá∫ÁöÑË¥πÁî®ÔºöGas‰ª∑Ê†ºÔºàÁî®‰ª•Â§™Â∏ÅËÆ°‰ª∑Ôºâ * GasÊï∞Èáè„ÄÇ ‰ª•Â§™ÂùäÂÆ¢Êà∑Á´ØÁõÆÂâçÊúâGoËØ≠Ë®ÄÂÆûÁé∞ÁöÑÂÆ¢Êà∑Á´ØGethÔºåÁî®C++ÂÆûÁé∞ÁöÑÂÆ¢Êà∑Á´ØEthÔºåPythonÂÆûÁé∞ÁöÑÂÆ¢Êà∑Á´ØPyethappÂíåJavaÂÆûÁé∞ÁöÑÂÆ¢Êà∑Á´ØEthereumJ„ÄÇ‰ª•Â§™ÂùäÂåÖÊã¨‰∏Ä‰∏™‰∏ìÁî®ÁöÑÂÆ¢Êà∑Á´ØÊµèËßàÂô®Ôºå‰ΩøÂæóÁî®Êà∑ÂèØ‰ª•ËøêË°åÂêÑÁßçÂêÑÊ†∑ÁöÑÂéª‰∏≠ÂøÉÂåñÂ∫îÁî®ÔºàDAppÔºâÔºåÂèëÂ∏ÉÊô∫ËÉΩÂêàÁ∫¶ÔºåËøô‰∏ÄÁ±ªÊµèËßàÂô®Ë¢´Áß∞‰∏∫Mist„ÄÇMistÁî±ÁâπÊÆäÁöÑÂÆâÂÖ®Â±Ç„ÄÅÂØÜÂåôÁÆ°ÁêÜ„ÄÅÂéª‰∏≠ÂøÉÂåñË¥¶Êà∑ÁÆ°ÁêÜÂíå‰∏éÂå∫ÂùóÈìæÁõ∏ÂÖ≥ÁöÑÁªÑ‰ª∂Âá†ÈÉ®ÂàÜÁªÑÊàê„ÄÇ‰ªéÁî®Êà∑‰ΩìÈ™åËßíÂ∫¶ËÄåË®ÄÔºåÂèØ‰ª•Âú®Mist‰∏≠‰ΩøÁî®DAppÔºåÂ∞±ÂÉèÈÄöËøáÂ∏∏ËßÑÊµèËßàÂô®‰∏éÁΩëÁ´ôËøõË°å‰∫§‰∫í‰∏ÄÊ†∑„ÄÇ Â∫îÁî®AugurÔºàAugur - HomeÔºâ‰∏Ä‰∏™Âéª‰∏≠ÂøÉÂåñÈ¢ÑÊµãÁ≥ªÁªüMakerÔºàMakerDAO - Stability for the blockchainÔºâ‰∏Ä‰∏™ÈáëËûçÁ±ªÂéª‰∏≠ÂøÉÂåñËá™Ê≤ªÁªÑÁªá ËÅîÁõüÈìæËÅîÁõüÈìæ‰ªÖÈôê‰∫éËÅîÁõüÊàêÂëòÂèÇ‰∏éÔºåÂå∫ÂùóÈìæ‰∏äÁöÑËØªÂÜôÊùÉÈôê„ÄÅÂèÇ‰∏éËÆ∞Ë¥¶ÊùÉÈôêÊåâÁÖßËÅîÁõüËßÑÂàôÊù•Âà∂ÂÆöÔºåÂ¶ÇÂå∫ÂùóÈìæËÅîÁõüR3ÂíåË∂ÖÁ∫ßË¥¶Êú¨ÔºàhyperlederÔºâ„ÄÇ Ë∂ÖÁ∫ßË¥¶Êú¨Ôºà HyperledgerÔºâË∂ÖÁ∫ßË¥¶Êú¨È°πÁõÆÊòØÁî±LinuxÂü∫Èáë‰ºö‰∫é2015Âπ¥12ÊúàÂêØÂä®ÁöÑÂºÄÊ∫êÈ°πÁõÆÔºåÊó®Âú®Êé®Âä®ÂêÑÊñπÂçè‰ΩúÔºåÂÖ±ÂêåÊâìÈÄ†Êú∫ÈÅáÂå∫ÂùóÈìæÁöÑ‰ºÅ‰∏öÁ∫ßÂàÜÂ∏ÉÂºèË¥¶Êú¨Â∫ïÂ±ÇÊäÄÊúØÔºåÁî®‰∫éÊûÑÂª∫ÊîØÊíë‰∏öÂä°ÁöÑË°å‰∏öÂ∫îÁî®ÂíåÂπ≥Âè∞„ÄÇË∂ÖÁ∫ßË¥¶Êú¨ÊòØÁî±Â§ß‰ºÅ‰∏öÈ¢ÜË°îÁöÑÂïÜ‰∏öÂåñËÅîÁõüÈìæÈ°πÁõÆ„ÄÇ È°πÁõÆÁÆ°ÁêÜÂΩ¢ÂºèÁêÜ‰∫ã‰ºöÔºöË¥üË¥£Êó•Â∏∏‰∫ãÂä°ÁÆ°ÁêÜÔºåÂåÖÊã¨ÂÆ°Ê†∏È¢ÑÁÆó„ÄÅÁõëÁù£È°πÁõÆÂíåÂ∏ÇÂú∫Ê¥ªÂä®„ÄÅË°®ÂÜ≥ÈáçË¶Å‰∫ãÈ°πÁ≠âËÅåË¥£„ÄÇÊäÄÊúØÊåáÂØºÂßîÂëò‰ºöÔºöÈ°πÁõÆÁöÑË¥°ÁåÆËÄÖÊàñÁª¥Êä§ËÄÖÈÄâ‰∏æ‰∫ßÁîüÔºå‰∏ªË¶Å‰ªªÂä°ÊòØÂú®ÊäÄÊúØ‰∏ä‰øùËØÅÈ°πÁõÆÊ≠£Â∏∏ËøõË°åÔºåÂåÖÊã¨Âà∂ÂÆöÊäÄÊúØÊñπÂêë„ÄÅÂÆ°ÊâπÈ°πÁõÆËÆÆÊ°àÁ≠â„ÄÇ‰ªª‰ΩïË¥°ÁåÆ‰ª£Á†Å„ÄÅÊñáÊ°£Á≠âÊäÄÊúØÊÄß‰∫ßÂìÅÁöÑ‰∫∫ÈÉΩÂèØ‰ª•Áß∞‰∏∫Ë¥°ÁåÆËÄÖ„ÄÇÂ∏ÇÂú∫ÂßîÂëò‰ºöÁî®Êà∑È°æÈóÆÂõ¢ FabricFabric‰∏∫Â∫îÁî®Êèê‰æõ‰∫ÜgRPC APIÔºå‰ª•ÂèäÂ∞ÅË£ÖAPIÁöÑSDK‰æõÂ∫îÁî®Ë∞ÉÁî®„ÄÇÂ∫îÁî®ÂèØ‰ª•ÈÄöËøáSDKËÆøÈóÆFabricÁΩëÁªú‰∏≠ÁöÑÂ§öÁßçËµÑÊ∫êÔºåÂåÖÊã¨Ë¥¶Êú¨„ÄÅ‰∫§Êòì„ÄÅÈìæÁ†Å„ÄÅ‰∫ã‰ª∂„ÄÅÊùÉÈôêÁÆ°ÁêÜÁ≠â„ÄÇÂ∫îÁî®ÂºÄÂèëËÄÖÂè™ÈúÄË¶ÅË∑üËøô‰∫õËµÑÊ∫êÊâì‰∫§ÈÅìÂç≥ÂèØÔºåÊó†ÈúÄÂÖ≥ÂøÉÂ¶Ç‰ΩïÂÆûÁé∞„ÄÇÂÖ∂‰∏≠ÔºåË¥¶Êú¨ÊòØÊúÄÊ†∏ÂøÉÁöÑÁªìÊûÑÔºåËÆ∞ÂΩïÂ∫îÁî®‰ø°ÊÅØÔºåÂ∫îÁî®ÂàôÈÄöËøáÂèëËµ∑‰∫§ÊòìÊù•ÂêëË¥¶Êú¨‰∏≠ËÆ∞ÂΩïÊï∞ÊçÆ„ÄÇ‰∫§ÊòìÊâßË°åÁöÑÈÄªËæëÈÄöËøáÈìæÁ†ÅÊù•ÊâøËΩΩ„ÄÇÊï¥‰∏™ÁΩëÁªúËøêË°å‰∏≠ÂèëÁîüÁöÑ‰∫ã‰ª∂ÂèØ‰ª•Ë¢´Â∫îÁî®ËÆøÈóÆÔºå‰ª•Ëß¶ÂèëÂ§ñÈÉ®ÊµÅÁ®ãÁîöËá≥ÂÖ∂‰ªñÁ≥ªÁªü„ÄÇÊùÉÈôêÁÆ°ÁêÜÂàôË¥üË¥£Êï¥‰∏™ËøáÁ®ã‰∏≠ÁöÑËÆøÈóÆÊéßÂà∂„ÄÇË¥¶Êú¨Âíå‰∫§ÊòìËøõ‰∏ÄÊ≠•Âú∞‰æùËµñÊ†∏ÂøÉÁöÑÂå∫ÂùóÈìæÁªìÊûÑ„ÄÅÊï∞ÊçÆÂ∫ì„ÄÅÂÖ±ËØÜÊú∫Âà∂Á≠âÊäÄÊúØÔºõÈìæÁ†ÅÂàô‰æùËµñÂÆπÂô®„ÄÅÁä∂ÊÄÅÊú∫Á≠âÊäÄÊúØÔºõÊùÉÈôêÁÆ°ÁêÜÂà©Áî®‰∫ÜÂ∑≤ÊúâÁöÑPKI‰ΩìÁ≥ª„ÄÅÊï∞Â≠óËØÅ‰π¶„ÄÅÂä†Ëß£ÂØÜÁÆóÊ≥ïÁ≠âËØ∏Â§öÂÆâÂÖ®ÊäÄÊúØ„ÄÇÂ∫ïÂ±ÇÁî±Â§ö‰∏™ËäÇÁÇπÁªÑÊàêP2PÁΩëÁªúÔºåÈÄöËøágRPCÈÄöÈÅìËøõË°å‰∫§‰∫íÔºåÂà©Áî®GossipÂçèËÆÆËøõË°åÂêåÊ≠•„ÄÇFabric‰æßÈáç‰∫éÊùÉÈôêÊéßÂà∂„ÄÅÁßÅÂØÜÊÄß‰øùÊä§Âíå‰∫§ÊòìÊÄßËÉΩÊèêÈ´ò„ÄÇ Sawtooth LakeËøô‰∏™Â∑•Á®ãÁß∞‰∏∫‚ÄùÈîØÈΩøÊπñ‚ÄùÔºåÂØπ‰∫éÂàõÂª∫ÔºåÈÉ®ÁΩ≤ÂíåËøêË°åÂàÜÂ∏ÉÂºèË¥¶Êú¨Êù•ËØ¥ÂÆÉÊòØ‰∏Ä‰∏™È´òÂ∫¶Ê®°ÂùóÂåñÂπ≥Âè∞ÁöÑÂ∑•Á®ãÔºåÂàÜÂ∏ÉÂºèË¥¶Êú¨Êèê‰æõÊï∞ÊçÆËÆ∞ÂΩïÁª¥Êä§‰∏Ä‰∏™Âéª‰∏≠ÂøÉÂåñÊùÉÂ®ÅÂíåÂÆûÁé∞„ÄÇ‰ª£ÊõøÂçï‰∏™ÈõÜ‰∏≠ÂºèÊï∞ÊçÆÂ∫ìÔºåÂàÜÂ∏ÉÂºèÂ∏êÊú¨‰∏≠ÁöÑÂèÇ‰∏éËÄÖ‰∏∫ÂÖ±‰∫´ËÆ°ÁÆóË¥°ÁåÆËµÑÊ∫êÔºåÁ°Æ‰øùÂØπÂàÜÂ∏ÉÂºèÂ∏êÊú¨ÁöÑÁä∂ÊÄÅÁöÑÊôÆÈÅç‰∏ÄËá¥„ÄÇÊØîÁâπÂ∏ÅÊòØÊúÄÊµÅË°åÁöÑÂàÜÂ∏ÉÂºèÂàÜÂ∏êÊú¨ÔºåËØ•ÊäÄÊúØÂ∑≤ÁªèË¢´ÊèêËÆÆÁî®‰∫éÂõΩÈôÖÊ±áÊ¨æÔºå‰øùÈô©Á¥¢ËµîÂ§ÑÁêÜÔºå‰æõÂ∫îÈìæÁÆ°ÁêÜÂíåÁâ©ËÅîÁΩëÔºàIoTÔºâÁöÑËÆ∏Â§ö‰∏çÂêåÁöÑÂ∫îÁî®Âú∫ÊôØ„ÄÇÂú®ÈîØÈΩøÊπñÈ°πÁõÆ‰∏≠ÁöÑÂàÜÂ∏ÉÂºèË¥¶Êú¨ÂåÖÊã¨3‰∏™ÁªÑ‰ª∂Ôºö‰ª£Ë°®Ë¥¶Êú¨Áä∂ÊÄÅÁöÑÊï∞ÊçÆÊ®°ÂûãÔºõÊîπÂèòË¥¶Êú¨Áä∂ÊÄÅÁöÑ‰∫§ÊòìËØ≠Ë®ÄÔºõÂú®ÂèÇ‰∏éËÄÖ‰πãÈó¥Âª∫Á´ã‰∫§ÊòìÁªìÊûúÂÖ±ËØÜÁöÑÂçèËÆÆ„ÄÇÈîØÈΩøÊπñ‰æßÈáç‰∫éÊèê‰æõÂÆåÊï¥ÁöÑ‰∫§ÊòìÂÆ∂ÊóèÂíåËäÇËÉΩÁöÑÂÖ±ËØÜÁÆóÊ≥ï„ÄÇFabricÂíåSawtoothÈÉΩÊèê‰æõ‰∫ÜÂàÜÂ∏ÉÂºèË¥¶Êú¨ÁöÑÂÆûÁé∞„ÄÇ IrohaIrohaÂèØ‰ª•ÂÆåÂñÑFabric„ÄÅÈîØÈΩøÊπñÂíåÂÖ∂‰ªñÊúâÊΩúÂäõÁöÑÈ°πÁõÆÔºåÈÄöËøáÁî®C++ÂàõÈÄ†ÂèØÈáçÂ§ç‰ΩøÁî®ÁöÑË¶ÅÁ¥†ÔºåËÉΩË¢´GO‰∏ÄÁ±ªÁöÑËØ≠Ë®ÄÁºñËØë„ÄÇÈÄöËøáËøôÁßçÊñπÊ≥ïÔºåIrohaËÉΩËûçÂÖ•Áé∞ÊúâÈ°πÁõÆÔºåÂÖ∂ÈïøÊúüÁõÆÊ†áÊòØÂÆûÁé∞‰∏Ä‰∏™ÂÅ•ÂÖ®ËµÑÊ∫êÂ∫ìÔºåË∂ÖÁ∫ßË¥¶Êú¨ÊäÄÊúØÈ°πÁõÆÂú®ËøêË°åÂàÜÂ∏ÉÂºèË¥¶Êú¨Êó∂ÔºåËÉΩËá™Áî±Âú∞ÈÄâÊã©Âπ∂‰ΩøÁî®Ëøô‰∫õÂèØÈáçÂ§ç‰ΩøÁî®ÁöÑÂÖÉÁ¥†„ÄÇÂ∞ΩÁÆ°ÈÄöËøájavaÔºàËøêË°åJVMÊ≤ôÁõíÔºâÁöÑchaincodeÂÆåÂñÑÊô∫ËÉΩÂêàÁ∫¶‰πüÊòØÂèØË°åÁöÑÔºå‰ΩÜIrohaÁöÑÁî®Êà∑‰∏çÈúÄË¶ÅÂÜôchaincodeÊù•Á°ÆÂÆöÊï∞Â≠óËµÑ‰∫ß„ÄÇ‰ΩøÁî®Ë¥ßÂ∏ÅÂíåÂèëÁü≠‰ø°ËøôÊ†∑ÁöÑÊôÆÈÄöÂú∫ÊôØ‰πüÊòØÊ†∏ÂøÉÊûÑÊû∂ÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ BurrowBurrowÊòØ‰∏ÄÁßç‰ªé‰ª•Â§™ÂùäË°çÁîüÂá∫Êù•ÁöÑ‰ª£Á†ÅÂ∫ìÔºåÁÅµÊÑüÊù•Ëá™‰∫éMonaxÂú®2014Âπ¥ÂºÄÂèëÂíåÂºÄÊ∫êÁöÑ‰∏ÄÁßçÂè´ÂÅöeris-dbÁöÑÊäÄÊúØ„ÄÇËØ•È°πÁõÆÁî±Ëã±ÁâπÂ∞îÂíåMonaxÊèêÂá∫Ôºå‰∏∫ÂïÜ‰∏öÂÖ¨Âè∏ÂíåÁªÑÁªáÊèê‰æõ‰∫Ü‰∏Ä‰∏™Êô∫ËÉΩÂêàÁ∫¶Âπ≥Âè∞„ÄÇ ‰æùÊâò‰ª•Â§™ÂùäÂº∫Â§ßÁöÑÂºÄÂèëÊ°ÜÊû∂ÂíåÁÅµÊ¥ªÁöÑÂéª‰∏≠ÂøÉÂåñÂ∫îÁî®ÁîüÊÄÅÁ≥ªÁªüÔºåBurrowÂ∞Ü‰ºöÊèê‰æõ‰∏ÄÁßçÂøÖË¶ÅÁöÑÂü∫Á°ÄËÆæÊñΩÁªôÈÇ£‰∫õÂØªÊ±ÇÂà©Áî®Âü∫‰∫éÂå∫ÂùóÈìæÁöÑÊô∫ËÉΩÂêàÁ∫¶Áî®‰∫éÂïÜ‰∏öËøêËê•ÁöÑ‰ºÅ‰∏öÂíåË∂ÖÁ∫ßË¥¶Êú¨ÊàêÂëò„ÄÇ ÁßÅÊúâÈìæÁßÅÊúâÈìæ‰ªÖÂú®ÁßÅÊúâÁªÑÁªá‰ΩøÁî®ÔºåÂå∫ÂùóÈìæ‰∏äÁöÑËØªÂÜôÊùÉÈôê„ÄÅÂèÇ‰∏éËÆ∞Ë¥¶ÊùÉÈôêÊåâÁßÅÊúâÁªÑÁªáËßÑÂàôÂà∂ÂÆöÔºå‰∏ÄËà¨ÊòØ‰ºÅ‰∏öÂÜÖÈÉ®ÁöÑÂ∫îÁî®„ÄÇ ‰æßÈìæËÉΩÂíåÊØîÁâπÂ∏ÅÂå∫ÂùóÈìæ‰∫§‰∫íÔºåÂπ∂‰∏éÊØîÁâπÂ∏ÅÊåÇÈí©ÁöÑÂå∫ÂùóÈìæ„ÄÇÊØîÁâπÂ∏ÅÊòØÂ§ßÂÆ∂ÂÖ¨ËÆ§ÁöÑÂÖ¨ÂÖ±ÈìæÔºå‰ΩÜËßÑÂàôÁõ∏ÂØπÂõ∫ÂÆöÔºå‰∫§ÊòìÈÄüÂ∫¶ËæÉÊÖ¢ÔºåÊâÄ‰ª•ÈÄöËøá‰æßÈìæÊèêÈ´òÊïàÁéáÊòØ‰∏Ä‰∏™ÊúâÊïàÂÅöÊ≥ï„ÄÇ ‰∫íËÅîÈìæÈíàÂØπÁâπÂÆöÈ¢ÜÂüüÁöÑÂ∫îÁî®ÂèØËÉΩ‰ºöÂΩ¢ÊàêÂêÑËá™ÂûÇÁõ¥È¢ÜÂüüÁöÑÂå∫ÂùóÈìæÔºåËøô‰∫õÂå∫ÂùóÈìæ‰ºöÊúâ‰∫íËÅî‰∫íÈÄöÁöÑÈúÄÊ±ÇÔºåÈÄöËøáÊüêÁßç‰∫íËÅî‰∫íÈÄöÂçèËÆÆËøûÊé•Ëµ∑Êù•ÔºåÂΩ¢ÊàêÂå∫ÂùóÈìæÂÖ®ÁêÉÁΩëÁªú 3.Âü∫‰∫éÊØîÁâπÂ∏ÅÁöÑÊñπÊ°àÈó™ÁîµÁΩëÁªúÈó™ÁîµÁΩëÁªúÔºàLightning NetworkÔºâÊòØ‰∏Ä‰∏™Âéª‰∏≠ÂøÉÂåñÁöÑÁ≥ªÁªü„ÄÇÈó™ÁîµÁΩëÁªúÁöÑÂçìË∂ä‰πãÂ§ÑÂú®‰∫éÔºåÊó†ÈúÄ‰ø°‰ªªÂØπÊñπ‰ª•ÂèäÁ¨¨‰∏âÊñπÂç≥ÂèØÂÆûÁé∞ÂÆûÊó∂ÁöÑ„ÄÅÊµ∑ÈáèÁöÑ‰∫§ÊòìÁΩëÁªú„ÄÇÂÆÉÂà©Áî®‰∫Ü‰∫ÜÊØîÁâπÂ∏ÅÁöÑÂÆâÂÖ®ÁâπÊÄßÔºåÂú®Á∫ø‰∏ãÊèê‰æõÈ´òÈÄüÁöÑÂÆûÊó∂‰∫§ÊòìÂ§ÑÁêÜËÉΩÂäõ„ÄÇÁî®Êà∑Êó¢ÂèØ‰ª•ÈÄöËøáÁÇπÂØπÁÇπÁöÑÁõ¥Êé•ÊîØ‰ªòÊñπÂºèÔºå‰πüÂèØ‰ª•ÈÄöËøáÁΩëÁªúË∑ØÁî±ÁöÑÊñπÂºèÂÆûÁé∞Èó¥Êé•ÊîØ‰ªò„ÄÇÈó™ÁîµÁΩëÁªúÁöÑÂÖ≥ÈîÆÊäÄÊúØÊúâ‰∏âÔºåÂêéÂêé‰æùËµñ‰∫éÂâçÂâçÔºå‰æùÊ¨°ÊòØÔºöRSMCÔºåHTLCÂíåÈó™ÁîµÁΩëÁªú„ÄÇÊäÄÊúØÂÆûÁé∞ËôΩÁÑ∂Â§çÊùÇÔºå‰ΩÜÊú¨Ë¥®Âç¥ÂæàÁÆÄÂçï„ÄÇRSMCÔºöÈó™ÁîµÁΩëÁªúÁöÑÂü∫Á°ÄÊòØ‰∫§ÊòìÂèåÊñπ‰πãÈó¥ÁöÑÂèåÂêëÂæÆÊîØ‰ªòÈÄöÈÅìÔºåRSMCÔºàRecoverable Sequence Maturity ContractÔºâÂÆö‰πâ‰∫ÜËØ•ÂèåÂêëÂæÆÊîØ‰ªòÈÄöÈÅìÁöÑÊúÄÂü∫Êú¨Â∑•‰ΩúÊñπÂºè„ÄÇHTLCÔºö RSMCÂè™ÊîØÊåÅÊúÄÁÆÄÂçïÁöÑÊó†Êù°‰ª∂ËµÑÈáëÊîØ‰ªòÔºåHTLCÔºàHashed Timelock ContractÔºâËøõ‰∏ÄÊ≠•ÂÆûÁé∞‰∫ÜÊúâÊù°‰ª∂ÁöÑËµÑÈáëÊîØ‰ªòÔºåÈÄöÈÅì‰ΩôÈ¢ùÁöÑÂàÜÈÖçÊñπÂºè‰πüÂõ†Ê≠§ÂèòÂæóÊõ¥‰∏∫Â§çÊùÇ„ÄÇRSMCÈÄöËøáÂ∑ßÂ¶ôÁöÑËÆæÁΩÆCommitment TXÁöÑÂ§öÈáçÁ≠æÂêçËæìÂá∫Ôºå‰ª•ÂèäsequenceÁöÑÂª∂ËøüËøõÂùóÂΩ¢ÊàêÊÉ©ÁΩöÁ™óÂè£ÊúüÔºåËß£ÂÜ≥‰∫ÜÂú®ÂæÆÊîØ‰ªòÈÄöÈÅì‰∏≠ÁöÑÂ∏ÅÂçïÂêëÊµÅÂä®ÈóÆÈ¢ò„ÄÇ Èõ∑ÁîµÁΩëÁªúRAIDENÁΩëÁªúÊòØ‰∏Ä‰∏™Á¶ªÈìæËßÑÊ®°ÁöÑËß£ÂÜ≥ÊñπÊ°àÔºå‰ΩøËøëÂç≥Êó∂Ôºå‰ΩéË¥πÁî®ÂíåÂèØÊâ©Â±ïÁöÑÊîØ‰ªò„ÄÇÊòØ‰ª•Â§™ÂùäÁ§æÂå∫ÊèêÂá∫ÁöÑÈìæ‰∏ãÂæÆÊîØ‰ªòÈÄöÈÅìËß£ÂÜ≥ÊñπÊ°à„ÄÇAÂêëDËΩ¨Ë¥¶ÔºåÁªèÁî±BÂíåCÁöÑÊîØ‰ªòÈÄöÈÅì‰∏≠‰ªã„ÄÇAÊûÑÈÄ†Áî±secretËß£ÈîÅÁöÑÂìàÂ∏åÈîÅÂêëBËΩ¨Ë¥¶ÔºåÁî±BÂíåCÊåâÂêåÊ†∑ÁöÑsecretËß£ÈîÅÊù°‰ª∂‰æùÊ¨°ÊûÑÈÄ†ÂêëCÂíåDÁöÑÂìàÂ∏åÈîÅËΩ¨Ë¥¶„ÄÇÁÑ∂ÂêéAÂêëDÊèê‰æõËß£ÈîÅÁöÑsecret„ÄÇDÂêëCÂá∫Á§∫secretÔºåÊãøÂà∞ÂìàÂ∏åÈîÅËΩ¨Ë¥¶‰∏≠Ë¢´ÈîÅÂÆöÁöÑ‰ª£Â∏ÅÔºåÂπ∂ÂæóÂà∞CÂêëDËΩ¨Ë¥¶ÁöÑ‰ΩôÈ¢ùËØÅÊòé„ÄÇÊúÄÂêéCÂíåBÈáçÂ§çÊ≠§Êìç‰Ωú„ÄÇ‰∫§ÊòìÂèåÊñπÂè™Ë¶ÅÂú®Èìæ‰∏äÂ≠òÂú®‰∫§ÊòìÈÄöÈÅìÔºåÂ∞±ËÉΩÂú®Èìæ‰∏ãÂü∫‰∫éË¢´ÈîÅÂÆöÁöÑ‰ΩôÈ¢ùËøõË°åÈ´òÈ¢ë„ÄÅÂèåÂêëÁöÑÂç≥Êó∂Á°ÆËÆ§‰∫§Êòì„ÄÇÂ§ö‰∏™ÈÄöÈÅìÂΩ¢ÊàêÁöÑÊîØ‰ªòË∑ØÂæÑÊûÑÊàê‚ÄúÈõ∑ÁîµÁΩëÁªú‚Äù„ÄÇ 4.ÊÄªÁªìËøôÂá†Â§©ÈòÖËØª‰∫Ü‰∏Ä‰∫õÂçöÂÆ¢Âíå„ÄäÂå∫ÂùóÈìæÊäÄÊúØÊåáÂçó„ÄãÔºå‰∫ÜËß£Âà∞Âå∫ÂùóÈìæÁöÑ‰∏Ä‰∫õÂ∫îÁî®„ÄÇÂå∫ÂùóÈìæÁõÆÂâçÂëºÂ£∞ÂæàÈ´òÔºåÁÇôÊâãÂèØÁÉ≠ÔºåÂ∏åÊúõ‰ª•ÂêéËÉΩÊúâÊõ¥Âä†Ê∑±ÂÖ•ÁöÑÂ≠¶‰π†„ÄÇ ‰ª•Â§™ÂùäÊòØ‰ªÄ‰πà - ‰ª•Â§™ÂùäÂºÄÂèëÂÖ•Èó®ÊåáÂçó - TinyÁÜä - ÂçöÂÆ¢Âõ≠Ë¢ÅÂãá, &amp; ÁéãÈ£ûË∑É. (2016). Âå∫ÂùóÈìæÊäÄÊúØÂèëÂ±ïÁé∞Áä∂‰∏éÂ±ïÊúõ. Ëá™Âä®ÂåñÂ≠¶Êä•, 42(4), 481-494.Ë∂ÖÁ∫ßË¥¶Êú¨FabricÁöÑÊû∂ÊûÑ‰∏éËÆæËÆ° - CSDNÂçöÂÆ¢Fabric ¬∑ GitHubhttps://github.com/hyperledgerÂå∫ÂùóÈìæÊäÄÊúØÊåáÂçó.ÈÇπÂùáËØ¶Ëß£ÊúÄËøëÂ§ßÁÉ≠ÁöÑÈó™ÁîµÁΩëÁªú„ÄÅÈõ∑ÁîµÁΩëÁªúÂíåCORDAÂ∑¥ÊØîÁâπÊúçÂä°‰∫éÂå∫ÂùóÈìæÂàõÊñ∞ËÄÖÈó™ÁîµÁΩëÁªúÂíåÈõ∑ÁîµÁΩëÁªúËØ¶Ëß£GitHub - raiden-network/raiden: Raiden Network]]></content>
      <categories>
        <category>Âå∫ÂùóÈìæ</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩï(‰∫å)]]></title>
    <url>%2F2018%2F04%2F20%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∫åÔºâÁúã‰π¶ÁúãÂà∞Êï∞ÁªÑ‰ªäÂ§©Â∞±Âà∑‰∏ãÊï∞ÁªÑÂêß„ÄÇ‰ªäÂ§©‰∏äÁΩëÈ°µÁºñÁ®ãËØæÂ≠¶JS‰πüÊòØ‰∏ÄË®ÄÈöæÂ∞Ω‚Ä¶‚Ä¶ 561.Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ‚Ä¶, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) list.sort()Âú®python3ÈáåÂè™ÊúâkeyÂíåreverse‰∏§‰∏™ÂèÇÊï∞‰∫Ü„ÄÇ 566.Reshape the MatrixYou‚Äôre given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.Á¨¨‰∏ÄÁßçÁî®numpyÁöÑÊñπÊ≥ïÔºö1234567891011def matrixReshape(self, nums, r, c): &quot;&quot;&quot; :type nums: List[List[int]] :type r: int :type c: int :rtype: List[List[int]] &quot;&quot;&quot; try: return np.reshape(nums,(r,c)).tolist() except: return nums Á¨¨‰∫åÁßç123456def matrixReshape(self, nums, r, c): flat = sum(nums, []) if len(flat) != r * c: return nums tuples = zip(*([iter(flat)] * c)) return map(list, tuples) 766.Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.123456def isToeplitzMatrix(self, m): for i in range(len(m)-1): for j in range(len(m[0])-1): if m[i][j] != m[i+1][j+1]: return False return True 485.Max Consecutive Ones1234567891011def findMaxConsecutiveOnes(self, nums): maxc = 0 count = 0 for i in nums: if i == 1: count = count +1 else: maxc = max(maxc, count) count = 0 maxc = max(maxc, count) return maxc ËøôÈÅìÈ¢òÊÉ≥ËøáÂ∞ÜlistËΩ¨strÔºå‰ΩÜÊòØÊÑüËßâ‰ºöÂæàÊÖ¢ËÄå‰∏îÊ≤°ÊúâÂÜôÂá∫Êù• ( ¬¥‚ñΩÔΩÄ)ÊÉ≥ÂêÉËû∫ÁãÆÁ≤â]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩï(‰∏Ä)]]></title>
    <url>%2F2018%2F04%2F17%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCodeÂà∑È¢òËÆ∞ÂΩïÔºà‰∏ÄÔºâ‰∏∫‰∫ÜÂä†Âº∫Âü∫Á°ÄÂÜ≥ÂÆöÂà∑È¢òÔºå‰ªéleetcodeÁöÑÁÆÄÂçïÂºÄÂßãÔºå‰πüÊòØÂØπÊï∞ÊçÆÁªìÊûÑÁöÑÂ§ç‰π†Â∑©Âõ∫„ÄÇ 557.Reverse Words in a String IIIGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. 12def reverseWords(self, s): return &apos; &apos;.join(i[::-1] for i in s.split()) Âè¶Â§ñÂú®ËÆ®ËÆ∫Âå∫ÁúãÂà∞‰∏ÄÁßçËß£ÂÜ≥ÊñπÊ°àÔºö12def reverseWords(self, s): return &apos; &apos;.join(s.split()[::-1])[::-1] 344. Reverse StringWrite a function that takes a string as input and returns the string reversed.12def reverseString(self, s): return s[::-1] 819.Most Common Word1234567891011from collections import Counterimport reclass Solution(object): def mostCommonWord(self, paragraph, banned): words = Counter(re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, paragraph).lower().split()) ban = set(banned) for i in ban: if i in words: del words[i] words = words.most_common() return (words)[0][0] PS.12345def mostCommonWord(self, p, banned): words = re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, p).lower().split() res = collections.Counter(words).most_common() ban = set(banned) return iter(w for w, n in res if w not in ban).next() iter()ÂáΩÊï∞Ëé∑ÂèñËø≠‰ª£Âô®ÔºåÂØπËé∑ÂèñÂà∞ÁöÑËø≠‰ª£Âô®‰ΩøÁî®next()ÂáΩÊï∞Êù•Ëé∑Âèñ‰∏ã‰∏ÄÊù°Êï∞ÊçÆ ÂàöÂºÄÂßãÂà∑È¢òÊØîËæÉÈöæ‰∫ÜÔºåÂ∏åÊúõ‰ª•ÂêéËÉΩÂ§üÊõ¥ÁÜüÁªÉÂêß]]></content>
      <categories>
        <category>Êó•Â∏∏Âà∑È¢ò</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
