<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode刷题记录（五）]]></title>
    <url>%2F2018%2F05%2F03%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（五）噗 797. All Paths From Source to Target12345678def allPathsSourceTarget(self, graph): def dfs(cur, path): if cur == len(graph) - 1: res.append(path) else: for i in graph[cur]: dfs(i, path + [i]) res = [] dfs(0, [0]) return res 617.Merge Two Binary TreesGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.12345678910111213def mergeTrees(self, t1, t2): &quot;&quot;&quot; :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode &quot;&quot;&quot; if t1 and t2: root = TreeNode(t1.val+t2.val) root.left = self.mergeTrees(t1.left,t2.left) root.right = self.mergeTrees(t1.right,t2.right) return root else: return t1 or t2 728.Self Dividing Numbers12is_self_dividing = lambda num: &apos;0&apos; not in str(num) and all(num % int(digit) == 0 for digit in str(num)) return filter(is_self_dividing, range(left, right + 1)) Subdomain Visit Count123456789101112131415161718def subdomainVisits(self, cpdomains): &quot;&quot;&quot; :type cpdomains: List[str] :rtype: List[str] &quot;&quot;&quot; visits, res = &#123;&#125;, [] for domain in cpdomains: tmp = domain.split() count, doms = int(tmp[0]), tmp[1].split(&apos;.&apos;) for i in range(len(doms)): domain = &apos;.&apos;.join(doms[i:]) if visits.get(domain, 0): visits[domain] += count else: visits[domain] = count for v in visits.items(): res.append(str(v[1]) + &apos; &apos; + v[0]) return res 814.Binary Tree Pruning123456789class Solution: def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root root.left, root.right = self.pruneTree(root.left), self.pruneTree(root.right) return root if root.val == 1 or root.left or root.right else None 要认真学习啊！没有买到优衣库的T恤qwq]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（四）]]></title>
    <url>%2F2018%2F04%2F28%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（四）链表 237.Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.12345678class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 725.Split Linked List in Parts1234567891011121314151617181920def splitListToParts(self, root, k): &quot;&quot;&quot; :type root: ListNode :type k: int :rtype: List[ListNode] &quot;&quot;&quot; curr, length = root, 0 while curr: curr, length = curr.next, length + 1 chunk, longer = length//k, length%k res = [chunk + 1]*longer + [chunk]*(k-longer) prev, curr = None, root for index, num in enumerate(res): if prev: prev.next = None res[index] = curr for i in range(num): prev, curr = curr, curr.next return res 分三步：求长度，切块，把数据装进去 206.Reverse Linked List迭代不太懂id……12345678def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev 递归123456789def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 445.Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.123456789101112131415161718192021222324def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if not l1: return l2 if not l2: return l1 x1 = x2 = &apos;&apos; while l1: x1 += str(l1.val) l1 = l1.next while l2: x2 += str(l2.val) l2 = l2.next y = int(x1)+int(x2) y = str(y) head = next_node = ListNode(y[0]) for i in range(1, len(y)): next_node.next = ListNode(y[i]) next_node = next_node.next return head 328.Odd Even Linked List1234567891011121314151617def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; d1=odd=ListNode(0) d2=even=ListNode(0) i=1 while head: if i%2: odd.next,odd=head,head else: even.next,even=head,head head=head.next i+=1 odd.next,even.next=d2.next,None return d1.next 放五一了啦啦啦]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录（三）]]></title>
    <url>%2F2018%2F04%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（三）今天除了数组部分，再写一点链表吧( ̀⌄ ́) 695.Max Area of IslandGiven a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.1234567891011def maxAreaOfIsland(self, grid): m, n = len(grid), len(grid[0]) def dfs(i, j): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j]: grid[i][j] = 0 return 1 + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i + 1, j) + dfs(i, j - 1) return 0 areas = [dfs(i, j) for i in range(m) for j in range(n) if grid[i][j]] return max(areas) if areas else 0 283.Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.12345678def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; for i in range(nums.count(0)): nums.remove(0) nums.append(0) 另一种方法：123456def moveZeroes(self, nums): zero = 0 # records the position of &quot;0&quot; for i in xrange(len(nums)): if nums[i] != 0: nums[i], nums[zero] = nums[zero], nums[i] zero += 1 667.Beautiful Arrangement II简单来说就是给[n,k], 生成一个list，其中有n个正整数，正整数相减后的绝对值的结果有k个正整数。1234567891011121314a = [1]h = k+1l = 2for _k in range(k,0,-2): if _k == 1: a.append(h) break else: a.append(h) a.append(l) h -= 1 l += 1a.extend(range(k+2,n+1))return a 495.Teemo Attacking12345678910def findPoisonedDuration(self, tS, d): &quot;&quot;&quot; :type timeSeries: List[int] :type duration: int :rtype: int &quot;&quot;&quot; ans = len(tS)*d for i in range(1, len(tS)): ans -= max(0, d-tS[i]+tS[i-1]) return ans 448. Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.12def findDisappearedNumbers(self, nums): return list(set([i for i in range(1,len(nums)+1)]).difference(set(nums))) 另外一种标记的方法：12345for i in xrange(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] &gt; 0] 挺机智的…… 817.Linked List Components12345678910111213def numComponents(self, head, G): &quot;&quot;&quot; :type head: ListNode :type G: List[int] :rtype: int &quot;&quot;&quot; setG = set(G) res = 0 while head: if head.val in setG and (head.next == None or head.next.val not in setG): res += 1 head = head.next return res 不能沉迷塞尔达，要学习]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近看的区块链知识的小记录]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[1.区块链的定义区块链是以比特币为代表的数字加密货币体系 的核心支撑技术. 区块链技术的核心优势是去中心化, 能够通过运用数据加密、时间戳、分布式共识和经济激励等手段, 在节点无需互相信任的分布式系统中实现基于去中心化信用的点对点交易、协调与协作, 从而为解决中心化机构普遍存在的高成本、低效率和数据存储不安全等问题提供了解决方案。特点：去中心化、时序数据、集体维护、可编程和安全可信 区块链的基础架构模型 数据层：封装底层数据区块以及相关的数据加密和时间戳等技术 网络层：包括分布式组网机制、数据传播机制和数据验证机制等 共识层：封装网络节点的各类共识算法 激励层：将经济因素集成到区块链技术体系中，主要包括经济激励的发行机制和分配机制 合约层：封装各类脚本、算法和智能合约 应用层：区块链的各种应用场景和案例 上图为数据区块的结构，分为区块头和区块体两部分。最先找到正确的解随机数Nonce并经过全体矿工验证的矿工会获得当前区块的记帐权，获得记帐权的矿工将当前区块链接到前一区块，形成最新的区块主链。 2.区块链的分类公共链公共链对外公开，用户不用注册就能匿名参与，无需授权即可访问网络和区块链，是真正意义上的完全去中心化的区块链，如比特币和以太坊 以太坊以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。以太坊是个平台和编程语言，包括数字货币和用来构建和帆布分布式应用的以太脚本，是区块链与智能合约的完美结合，拥有一套完整的、可以扩展其功能的工具，在P2P网络、加密、HttpClient等技术的支持下实现了一个类似于比特币的区块链。 编程语言：Solidity以太坊具有4种专用语言：Serpent（长得像Python）、Solidity（JS）、Mutan（Go）和LLL（Lisp）智能合约的默认的编程语言是Solidity，文件扩展名以.sol结尾。Solidity是和JavaScript相似的语言，用它来开发合约并编译成以太坊虚拟机字节代码。 运行环境：EVMEVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。EVM是由许多互相连接的计算机组成的。任何人都可以为所有权、交易格式和状态转化函数创建商业逻辑。 以太坊账户以太坊内有两类账户。外部账户被公钥-私钥对控制，合约账户被存储在账户中的代码控制。外部账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取写入发送其他消息和创建合约。 Gas以太坊上的每笔交易都会被收取一定数量的燃料Gas，设置Gas的目的是限制交易执行所需的工作量，同时为交易的执行支付费用。任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。 以太坊客户端目前有Go语言实现的客户端Geth，用C++实现的客户端Eth，Python实现的客户端Pyethapp和Java实现的客户端EthereumJ。以太坊包括一个专用的客户端浏览器，使得用户可以运行各种各样的去中心化应用（DApp），发布智能合约，这一类浏览器被称为Mist。Mist由特殊的安全层、密匙管理、去中心化账户管理和与区块链相关的组件几部分组成。从用户体验角度而言，可以在Mist中使用DApp，就像通过常规浏览器与网站进行交互一样。 应用Augur（Augur - Home）一个去中心化预测系统Maker（MakerDAO - Stability for the blockchain）一个金融类去中心化自治组织 联盟链联盟链仅限于联盟成员参与，区块链上的读写权限、参与记账权限按照联盟规则来制定，如区块链联盟R3和超级账本（hyperleder）。 超级账本（ Hyperledger）超级账本项目是由Linux基金会于2015年12月启动的开源项目，旨在推动各方协作，共同打造机遇区块链的企业级分布式账本底层技术，用于构建支撑业务的行业应用和平台。超级账本是由大企业领衔的商业化联盟链项目。 项目管理形式理事会：负责日常事务管理，包括审核预算、监督项目和市场活动、表决重要事项等职责。技术指导委员会：项目的贡献者或维护者选举产生，主要任务是在技术上保证项目正常进行，包括制定技术方向、审批项目议案等。任何贡献代码、文档等技术性产品的人都可以称为贡献者。市场委员会用户顾问团 FabricFabric为应用提供了gRPC API，以及封装API的SDK供应用调用。应用可以通过SDK访问Fabric网络中的多种资源，包括账本、交易、链码、事件、权限管理等。应用开发者只需要跟这些资源打交道即可，无需关心如何实现。其中，账本是最核心的结构，记录应用信息，应用则通过发起交易来向账本中记录数据。交易执行的逻辑通过链码来承载。整个网络运行中发生的事件可以被应用访问，以触发外部流程甚至其他系统。权限管理则负责整个过程中的访问控制。账本和交易进一步地依赖核心的区块链结构、数据库、共识机制等技术；链码则依赖容器、状态机等技术；权限管理利用了已有的PKI体系、数字证书、加解密算法等诸多安全技术。底层由多个节点组成P2P网络，通过gRPC通道进行交互，利用Gossip协议进行同步。Fabric侧重于权限控制、私密性保护和交易性能提高。 Sawtooth Lake这个工程称为”锯齿湖”，对于创建，部署和运行分布式账本来说它是一个高度模块化平台的工程，分布式账本提供数据记录维护一个去中心化权威和实现。代替单个集中式数据库，分布式帐本中的参与者为共享计算贡献资源，确保对分布式帐本的状态的普遍一致。比特币是最流行的分布式分帐本，该技术已经被提议用于国际汇款，保险索赔处理，供应链管理和物联网（IoT）的许多不同的应用场景。在锯齿湖项目中的分布式账本包括3个组件：代表账本状态的数据模型；改变账本状态的交易语言；在参与者之间建立交易结果共识的协议。锯齿湖侧重于提供完整的交易家族和节能的共识算法。Fabric和Sawtooth都提供了分布式账本的实现。 IrohaIroha可以完善Fabric、锯齿湖和其他有潜力的项目，通过用C++创造可重复使用的要素，能被GO一类的语言编译。通过这种方法，Iroha能融入现有项目，其长期目标是实现一个健全资源库，超级账本技术项目在运行分布式账本时，能自由地选择并使用这些可重复使用的元素。尽管通过java（运行JVM沙盒）的chaincode完善智能合约也是可行的，但Iroha的用户不需要写chaincode来确定数字资产。使用货币和发短信这样的普通场景也是核心构架的一部分。 BurrowBurrow是一种从以太坊衍生出来的代码库，灵感来自于Monax在2014年开发和开源的一种叫做eris-db的技术。该项目由英特尔和Monax提出，为商业公司和组织提供了一个智能合约平台。 依托以太坊强大的开发框架和灵活的去中心化应用生态系统，Burrow将会提供一种必要的基础设施给那些寻求利用基于区块链的智能合约用于商业运营的企业和超级账本成员。 私有链私有链仅在私有组织使用，区块链上的读写权限、参与记账权限按私有组织规则制定，一般是企业内部的应用。 侧链能和比特币区块链交互，并与比特币挂钩的区块链。比特币是大家公认的公共链，但规则相对固定，交易速度较慢，所以通过侧链提高效率是一个有效做法。 互联链针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种互联互通协议连接起来，形成区块链全球网络 3.基于比特币的方案闪电网络闪电网络（Lightning Network）是一个去中心化的系统。闪电网络的卓越之处在于，无需信任对方以及第三方即可实现实时的、海量的交易网络。它利用了了比特币的安全特性，在线下提供高速的实时交易处理能力。用户既可以通过点对点的直接支付方式，也可以通过网络路由的方式实现间接支付。闪电网络的关键技术有三，后后依赖于前前，依次是：RSMC，HTLC和闪电网络。技术实现虽然复杂，但本质却很简单。RSMC：闪电网络的基础是交易双方之间的双向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定义了该双向微支付通道的最基本工作方式。HTLC： RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。RSMC通过巧妙的设置Commitment TX的多重签名输出，以及sequence的延迟进块形成惩罚窗口期，解决了在微支付通道中的币单向流动问题。 雷电网络RAIDEN网络是一个离链规模的解决方案，使近即时，低费用和可扩展的支付。是以太坊社区提出的链下微支付通道解决方案。A向D转账，经由B和C的支付通道中介。A构造由secret解锁的哈希锁向B转账，由B和C按同样的secret解锁条件依次构造向C和D的哈希锁转账。然后A向D提供解锁的secret。D向C出示secret，拿到哈希锁转账中被锁定的代币，并得到C向D转账的余额证明。最后C和B重复此操作。交易双方只要在链上存在交易通道，就能在链下基于被锁定的余额进行高频、双向的即时确认交易。多个通道形成的支付路径构成“雷电网络”。 4.总结这几天阅读了一些博客和《区块链技术指南》，了解到区块链的一些应用。区块链目前呼声很高，炙手可热，希望以后能有更加深入的学习。 以太坊是什么 - 以太坊开发入门指南 - Tiny熊 - 博客园袁勇, &amp; 王飞跃. (2016). 区块链技术发展现状与展望. 自动化学报, 42(4), 481-494.超级账本Fabric的架构与设计 - CSDN博客Fabric · GitHubhttps://github.com/hyperledger区块链技术指南.邹均详解最近大热的闪电网络、雷电网络和CORDA巴比特服务于区块链创新者闪电网络和雷电网络详解GitHub - raiden-network/raiden: Raiden Network]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录(二)]]></title>
    <url>%2F2018%2F04%2F20%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（二）看书看到数组今天就刷下数组吧。今天上网页编程课学JS也是一言难尽…… 561.Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) list.sort()在python3里只有key和reverse两个参数了。 566.Reshape the MatrixYou’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.第一种用numpy的方法：1234567891011def matrixReshape(self, nums, r, c): &quot;&quot;&quot; :type nums: List[List[int]] :type r: int :type c: int :rtype: List[List[int]] &quot;&quot;&quot; try: return np.reshape(nums,(r,c)).tolist() except: return nums 第二种123456def matrixReshape(self, nums, r, c): flat = sum(nums, []) if len(flat) != r * c: return nums tuples = zip(*([iter(flat)] * c)) return map(list, tuples) 766.Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.123456def isToeplitzMatrix(self, m): for i in range(len(m)-1): for j in range(len(m[0])-1): if m[i][j] != m[i+1][j+1]: return False return True 485.Max Consecutive Ones1234567891011def findMaxConsecutiveOnes(self, nums): maxc = 0 count = 0 for i in nums: if i == 1: count = count +1 else: maxc = max(maxc, count) count = 0 maxc = max(maxc, count) return maxc 这道题想过将list转str，但是感觉会很慢而且没有写出来 ( ´▽｀)想吃螺狮粉]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题记录(一)]]></title>
    <url>%2F2018%2F04%2F17%2FLeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录（一）为了加强基础决定刷题，从leetcode的简单开始，也是对数据结构的复习巩固。 557.Reverse Words in a String IIIGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. 12def reverseWords(self, s): return &apos; &apos;.join(i[::-1] for i in s.split()) 另外在讨论区看到一种解决方案：12def reverseWords(self, s): return &apos; &apos;.join(s.split()[::-1])[::-1] 344. Reverse StringWrite a function that takes a string as input and returns the string reversed.12def reverseString(self, s): return s[::-1] 819.Most Common Word1234567891011from collections import Counterimport reclass Solution(object): def mostCommonWord(self, paragraph, banned): words = Counter(re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, paragraph).lower().split()) ban = set(banned) for i in ban: if i in words: del words[i] words = words.most_common() return (words)[0][0] PS.12345def mostCommonWord(self, p, banned): words = re.sub(r&apos;[^a-zA-Z]&apos;, &apos; &apos;, p).lower().split() res = collections.Counter(words).most_common() ban = set(banned) return iter(w for w, n in res if w not in ban).next() iter()函数获取迭代器，对获取到的迭代器使用next()函数来获取下一条数据 刚开始刷题比较难了，希望以后能够更熟练吧]]></content>
      <categories>
        <category>日常刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
